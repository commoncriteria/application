<?xml version="1.0" encoding="utf-8"?>
<technical-decisions  xmlns:h="http://www.w3.org/1999/xhtml" 
		      xmlns="https://niap-ccevs.org/cc/v1">
  <bunch>
    <applies-to max-inclusive="1.4" name="Protection Profile for Application Software"/>

    <decision id='0717'>
    	<notes>Format changes for PP_APP_V1.4</notes>
		
		<change xpath=".//SO[@name='O.QUALITY']" mode="replace">
		<!-- TD changed FCS_CKM.1 to FCS_CKM_EXT.1 -->
			<SO name="O.QUALITY">
				<description>To ensure quality of implementation, conformant TOEs
					leverage services and APIs provided by the runtime environment rather
					than implementing their own versions of these services and APIs. This is especially
					important for cryptographic services and other complex operations such as file and media
					parsing. Leveraging this platform behavior relies upon using only documented and supported APIs.
				</description>
				<addressed-by>FCS_CKM_ext.1</addressed-by><rationale>The PP supports this objective by allowing FCS_CKM_EXT.1 to specify that the TSF may rely on platform-provided key generation services.</rationale>
				<addressed-by>FCS_RBG_EXT.1</addressed-by><rationale>The PP supports this objective by allowing FCS_RBG_EXT.1 to specify that the TSF may rely on platform-provided random bit generation services.</rationale> 
				<addressed-by>FCS_STO_EXT.1</addressed-by><rationale>The PP supports this objective by allowing FCS_STO_EXT.1 to specify that the TSF may rely on platform-provided credential storage services.</rationale>
				<addressed-by>FDP_DAR_EXT.1</addressed-by><rationale>The PP supports this objective by allowing FDP_DAR_EXT.1 to specify that the TSF may rely on platform-provided data-at-rest protection services.</rationale>
				<addressed-by>FMT_MEC_EXT.1</addressed-by><rationale>The PP includes FMT_MEC_EXT.1 to ensure that the TOE can use platform services to store and set configuration options.</rationale>
				<addressed-by>FPT_API_EXT.1</addressed-by><rationale>The PP includes FPT_API_EXT.1 to require the TOE to leverage platform functionality by using only documented and supported APIs.</rationale>
				<addressed-by>FPT_LIB_EXT.1</addressed-by><rationale>The PP includes FPT_LIB_EXT.1 to ensure that the TOE does not include any unnecessary or unexpected third-party libraries which could present a privacy threat or vulnerability.</rationale>
				<addressed-by>FTP_DIT_EXT.1</addressed-by><rationale>The PP supports this objective by allowing FTP_DIT_EXT.1 to specify that the TSF may rely on platform-provided services to implement trusted communications.</rationale>
				<addressed-by>FCS_CKM.1/AK (selection-based)</addressed-by><rationale>The PP supports this objective by allowing FCS_CKM.1/AK to specify that the TSF may rely on platform-provided asymmetric key generation services.</rationale>
				<addressed-by>FCS_CKM.2 (selection-based)</addressed-by><rationale>The PP supports this objective by allowing FCS_CKM.2 to specify that the TSF may rely on platform-provided key establishment services.</rationale>
				<addressed-by>FIA_X509_EXT.1 (selection-based)</addressed-by><rationale>The PP supports this objective by allowing FIA_X509_EXT.1 to specify that the TSF may rely on platform-provided X.509 certificate validation services.</rationale>
				<addressed-by>FPT_TUD_EXT.2 (selection-based)</addressed-by><rationale>The TSF includes FPT_TUD_EXT.2 to specify that the TOE may leverage the platform-supported package manager for application distribution and leverages platform-provided mechanisms to remove all traces of itself when removed from the platform system.</rationale>
				<addressed-by>FPT_API_EXT.2 (objective)</addressed-by><rationale>The PP includes FPT_API_EXT.2 to permit the TOE to use platform-provided libraries for parsing IANA MIME media formats.</rationale>
            </SO>
		</change>
		
		<change xpath=".//SO[@name='O.PROTECTED_STORAGE']" mode="replace">
		<!-- TD changed FCS_CKM.1/PBKDC to FCS_CKM_EXT.1/PBKDC -->
			<SO name="O.PROTECTED_STORAGE">
				<description>
					To address the issue of loss of confidentiality of user data in the event of 
					loss of physical control of the storage medium, conformant TOEs will 
					use data-at-rest protection. This involves encrypting data and keys stored by the 
					TOE in order to prevent unauthorized access to this data.  This also
					includes unnecessary network communications whose consequence may be the loss of data.
				</description>
				<addressed-by>FCS_RBG_EXT.1</addressed-by><rationale>The PP includes FCS_RBG_EXT.1 to define whether random bit generation services are implemented by the TSF or the platform. Depending on how data at rest is protected, the TOE may rely on the use of a random bit generator to create keys that are subsequently used for data protection.</rationale>
				<addressed-by>FCS_STO_EXT.1</addressed-by><rationale>The PP includes FCS_STO_EXT.1 to define the mechanism that the TSF uses or relies upon to protect stored credential data.</rationale>
				<addressed-by>FDP_DAR_EXT.1</addressed-by><rationale>The PP includes FDP_DAR_EXT.1 to define the mechanism that the TSF uses or relies upon to protect sensitive data at rest.</rationale>
				<addressed-by>FCS_CKM.1/SK (optional)</addressed-by><rationale>The PP includes FCS_CKM.1/SK to define the TOE’s capability to generate symmetric keys. These keys may subsequently be used to encrypt stored credential data based on the claims made in FCS_STO_EXT.1.</rationale>
				<addressed-by>FCS_CKM_EXT.1/PBKDF (selection-based)</addressed-by><rationale>The PP includes FCS_CKM_EXT.1/PBKDF to define the password-based key derivation function that may be used to encrypt stored credential data based on the claims made in FCS_STO_EXT.1.</rationale>
				<addressed-by>FCS_COP.1/SKC (selection-based)</addressed-by><rationale>The PP includes FCS_COP.1/SKC to define the AES cryptographic algorithm that may be used to encrypt stored credential data based on the claims made in FCS_STO_EXT.1.</rationale>
				<addressed-by>FCS_COP.1/Hash (selection-based)</addressed-by><rationale>The PP includes FCS_COP.1/Hash to define integrity mechanisms that may be used by the TOE as part of ensuring that data at rest is protected.</rationale>
				<addressed-by>FCS_COP.1/KeyedHash (selection-based)</addressed-by><rationale>The PP includes FCS_COP.1/KeyedHash to define HMAC mechanisms that may be used by the TOE as part of ensuring that data at rest is protected.</rationale>
				<addressed-by>FCS_RBG_EXT.2 (selection-based)</addressed-by><rationale>The PP includes FCS_RBG_EXT.2 to define the TOE’s implementation of random bit generation functionality in the event that the TOE provides this function in support of generating keys that are used for data protection.</rationale>
            </SO>
		</change>
			
		<change xpath=".//SO[@name='O.PROTECTED_COMMS']" mode="replace">
		<!-- TD changed FCS_CKM.1 to FCS_CKM_EXT.1 -->	
			<SO name="O.PROTECTED_COMMS">
				<description> To address both passive (eavesdropping) and active (packet modification)
					network attack threats, conformant TOEs will use a trusted channel for
					sensitive data. Sensitive data includes cryptographic keys, passwords, and any other
					data specific to the application that should not be exposed outside of the application. 
				</description>
				<addressed-by>FCS_RBG_EXT.1</addressed-by><rationale>The PP includes FCS_RBG_EXT.1 to define whether the random bit generation services used in establishing trusted communications are implemented by the TSF or by the platform.</rationale>
				<addressed-by>FCS_CKM_EXT.1</addressed-by><rationale>The PP includes FCS_CKM_EXT.1 to specify whether the TOE or the platform is responsible for generation of any asymmetric keys that may be used for establishing trusted communications.</rationale>
				<addressed-by>FTP_DIT_EXT.1</addressed-by><rationale>The PP includes FTP_DIT_EXT.1 to define the trusted channels used to protect data in transit, the data that is protected, and whether the trusted channels are implemented by the TSF or the platform.</rationale>
				<addressed-by>FCS_CKM.1/AK</addressed-by><rationale>The PP includes FCS_CKM.1/AK to define whether the TSF or the platform generates asymmetric keys that are used in support of trusted communications.</rationale>
				<addressed-by>FCS_CKM.2</addressed-by><rationale>The PP includes FCS_CKM.2 to define whether the TSF or the platform performs key establishment for trusted communications.</rationale>
				<addressed-by>FCS_COP.1/SKC</addressed-by><rationale>The PP includes FCS_COP.1/SKC to define the symmetric encryption algorithms used in support of trusted communications.</rationale>
				<addressed-by>FCS_COP.1/Hash</addressed-by><rationale>The PP includes FCS_COP.1/Hash to define the hash algorithms used in support of trusted communications.</rationale>
				<addressed-by>FCS_COP.1/Sig</addressed-by><rationale>The PP includes FCS_COP.1/Sig to define the digital signature algorithms used in support of trusted communications.</rationale>
				<addressed-by>FCS_COP.1/KeyedHash</addressed-by><rationale>The PP includes FCS_COP.1/KeyedHash to define the HMAC algorithms used in support of trusted communications.</rationale>
				<addressed-by>FCS_RBG_EXT.2</addressed-by><rationale>The PP includes FCS_RBG_EXT.2 to define the DRBG algorithms used in support of trusted communications.</rationale>
				<addressed-by>FCS_HTTPS_EXT.1/Client</addressed-by><rationale>The PP includes FCS_HTTPS_EXT.1 to define the TOE’s support for the HTTPS trusted communications protocol as a client.</rationale>
				<addressed-by>FCS_HTTPS_EXT.1/Server</addressed-by><rationale>The PP includes FCS_HTTPS_EXT.1 to define the TOE’s support for the HTTPS trusted communications protocol as a server.</rationale>
				<addressed-by>FDP_NET_EXT.1</addressed-by><rationale>The PP includes FDP_NET_EXT.1 to define the TOE’s usage of network communications, which may include the transmission or receipt of data over a trusted channel.</rationale>
				<addressed-by>FIA_X509_EXT.1</addressed-by><rationale>The PP includes FIA_X509_EXT.1 to define X.509 certificate validation activities in support of trusted communications.</rationale>
				<addressed-by>FIA_X509_EXT.2</addressed-by><rationale>The PP includes FIA_X509_EXT.2 to define the trusted communications that X.509 certificate services support, as well as the extent to which trusted communications can be established when using a certificate with unknown validity.</rationale>
            </SO>
		</change>
		
	<!-- FCS_CKM_EXT.1 -->
	<!-- TD made formatting changes and changed FCS_CKM.1 to FCS_CKM_EXT.1 -->
	<change xpath=".//f-component[@cc-id='fcs_ckm.1']" mode="replace">
        <f-component cc-id="fcs_ckm_ext.1" name="Cryptographic Key Generation Services">
			<f-element id="fel-asym-key-gen">
				<title>
					The application shall <selectables linebreak="yes">
						<selectable exclusive="yes">generate no asymmetric cryptographic keys</selectable>
						<selectable id="sel_invoke_genkey">invoke platform-provided functionality for asymmetric key generation</selectable>
						<selectable id="sel_impl_genkey">implement asymmetric key generation</selectable>
					</selectables>.
				</title>
				<note role="application">If "<h:i>implement asymmetric key generation</h:i>" or 
					"<h:i>invoke platform-provided functionality for asymmetric key generation</h:i>" is chosen, then
					additional FCS_CKM.1/AK elements shall be included in the ST.
				</note>
				<aactivity level="element">
					<TSS>
						The evaluator shall inspect the application and its developer documentation 
						to determine if the application needs asymmetric key generation services. If not, the 
						evaluator shall verify the <h:b>generate no asymmetric cryptographic keys</h:b> selection is present 
						in the ST. Otherwise, the evaluation activities shall be performed as stated in the 
						selection-based requirements.<h:br/>
					</TSS>
					<Guidance>None.<h:br/></Guidance>
					<Tests>None.</Tests>
				</aactivity>
			</f-element>
        </f-component>
		</change>

	<!-- FCS_STO_EXT.1 -->
	<!-- TD replaced FCS_CKM.1/PBKDF with FCS_CKM_EXT.1/PBKDF -->
	<change xpath=".//f-element[@id='fel-store-creds']" mode="replace">
			<f-element id="fel-store-creds">
				<title>The application shall 
					<selectables linebreak="yes">
						<selectable exclusive="yes">not store any credentials</selectable>
						<selectable>invoke the functionality provided by the platform to securely store 
							<assignable>list of credentials</assignable>
						</selectable>
						<selectable id="sel_impl_sto">implement functionality to securely store
							<assignable>list of credentials</assignable>
							according to
							<selectables>
								<selectable id="sel-fcs-sto-skc">FCS_COP.1/SKC</selectable>
								<selectable id="sel-fcs-sto-pbkdf">FCS_CKM_EXT.1/PBKDF</selectable>
							</selectables>
						</selectable>
					</selectables>
					to non-volatile memory.
				</title>
				<note role="application">
					This requirement ensures that persistent credentials (secret keys, PKI private keys, passwords, etc) 
					are stored securely, and never persisted in cleartext form. 
					Application developers are encouraged to use platform mechanisms for the secure storage of credentials. 
					Depending on the platform that may include hardware-backed protection for credential storage. Application
					developers must choose a selection, or multiple selections, based on all credentials that the application
					stores. If "<h:i>not store any credentials</h:i>" is selected then the application must not store any credentials.
					If "<h:i>invoke the functionality provided by the platform to securely store</h:i>" is selected then the 
					Application developer must closely review the EA for their platform and provide documentation indicating
					which platform mechanisms are used to store credentials. 
					If "<h:i>implement functionality to securely store credentials</h:i>" is selected, then the following components 
					must be included in the ST: FCS_COP.1/SKC or FCS_CKM_EXT.1/PBKDF.
					If other cryptographic operations are used to implement the secure storage of credentials, the corresponding 
					requirements must be included in the ST. If the OS is Linux and Java KeyStores are used to store 
					credentials, "<h:i>implement functionality to securely store credentials</h:i>" must be selected.
				</note>           
				<aactivity>
					<TSS>The evaluator shall check the TSS to ensure that it lists all persistent 
						credentials (secret keys, PKI private keys, or passwords) needed to meet the 
						requirements in the ST. For each of these items, the evaluator shall 
						confirm that the TSS lists for what purpose it is used, and how it is stored. <h:p/>
					</TSS>              
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						For all credentials for which the application implements functionality, the evaluator shall 
						verify credentials are encrypted according to FCS_COP.1/SKC or conditioned according to
						FCS_CKM.1.1/AK and FCS_CKM_EXT.1/PBKDF.
						For all credentials for which the application invokes platform-provided
						functionality, the evaluator shall perform the following actions which vary per platform.
						<h:div><depends ref="android"/>The evaluator shall verify that the application uses
							the Android <h:code>KeyStore</h:code> or the Android <h:code>KeyChain</h:code> to store certificates.  
						</h:div>
						<h:div><depends ref="windows"/>The evaluator shall verify that all certificates are
							stored in the Windows Certificate Store. The evaluator shall verify that other
							credentials, like passwords, are stored in the Windows Credential Manager or stored 
							using the Data Protection API (DPAPI). For Windows Universal Applications, the evaluator shall 
							verify that the application is using the ProtectData class and storing credentials 
							in IsolatedStorage.
						</h:div>
						<h:div><depends ref="ios"/>
							The evaluator shall verify that all credentials are stored
							within a <h:code>Keychain</h:code>.  
						</h:div>
						<h:div><depends ref="linux"/>
							The evaluator shall verify that all keys are stored using Linux keyrings.
						</h:div>
						<h:div><depends ref="Solaris"/>
							The evaluator shall verify that all keys are stored using Solaris 
							<h:code>Key Management Framework (KMF)</h:code>.
						</h:div>
						<h:div><depends ref="mac"/>The evaluator shall verify that all credentials are 
							stored within <h:code>Keychain</h:code>.</h:div>
					</Tests>
				</aactivity>
			</f-element>
	</change>
		<!-- FCS_CKM.1/AK -->
		<!-- TD archived TD0659 and made formatting changes -->
        <change xpath=".//f-element[@id='fel-asym-key-gen-impl']" mode="replace">
		<f-element id="fel-asym-key-gen-impl">
				<title>            
					The <h:b>application</h:b> shall <selectables linebreak="yes" onlyone="yes">
						<selectable>invoke platform-provided functionality</selectable>
						<selectable>implement functionality</selectable>
					</selectables>
					to generate <h:b>asymmetric</h:b> cryptographic keys in accordance with a specified cryptographic key generation algorithm
					<selectables linebreak="yes">
						<selectable><h:b>[RSA schemes]</h:b> using cryptographic key sizes of <h:b>[2048-bit or greater]</h:b> that meet
							the following: <h:b> [FIPS PUB 186-4, "Digital Signature Standard (DSS)", Appendix B.3]</h:b></selectable>
						<selectable><h:b>[ECC schemes]</h:b> using <h:b>[“NIST curves” P-384 and <selectables>
							<selectable> P-256 </selectable>
							<selectable> P-521 </selectable>
							<selectable exclusive="yes"> no other curves </selectable></selectables> 
							</h:b>that meet the following: 
							<h:b>[FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Appendix B.4]</h:b>
						</selectable> 
						<selectable>
							<h:b>[FFC schemes]</h:b> using cryptographic key sizes of <h:b>[2048-bit or greater]</h:b> 
							that meet the following: <h:b>[FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Appendix B.1]</h:b>
						</selectable>
						<selectable><h:b>[FFC Schemes]</h:b><h:b> using [Diffie-Hellman group 14]</h:b> that meet the following: 
							<h:b>RFC 3526, Section 3]</h:b>
						</selectable>
						<selectable><h:b>[FFC Schemes]</h:b><h:b> using [“safe-prime” groups]</h:b> that meet the following: 
							<h:b>[NIST Special Publication 800-56A Revision 3, “Recommendation for Pair-Wise Key Establishment Schemes
								Using Discrete Logarithm Cryptography”</h:b> and 
							<selectables>
								<selectable>RFC 3526</selectable>
								<selectable>RFC 7919</selectable>
							</selectables>
						</selectable>  
					</selectables>].
				</title>
				<note role="application">
					The ST author shall select all key generation schemes used for key 
					establishment and entity authentication. When key generation is used for key 
					establishment, the schemes in FCS_CKM.2.1 and selected cryptographic protocols must 
					match the selection. When key generation is used for entity authentication, the public 
					key is expected to be associated with an X.509v3 certificate.<h:p/>
					If the TOE acts as a receiver in the RSA key establishment scheme, 
					the TOE does not need to implement RSA key generation. 
				</note>
				<aactivity level="element">
					<TSS>
						The evaluator shall ensure that the TSS identifies the key sizes 
						supported by the TOE. If the ST specifies more 
						than one scheme, the evaluator shall examine the TSS to verify that 
						it identifies the usage for each scheme.<h:p/>
						If the application "<h:i>invokes platform-provided functionality for asymmetric key generation</h:i>,"
						then the evaluator shall examine the TSS to verify that it describes 
						how the key generation functionality is invoked.<h:p/>
					</TSS>
					<Guidance> 
						The evaluator shall verify that the AGD guidance instructs the administrator how to 
						configure the TOE to use the selected key generation scheme(s) and 
						key size(s) for all uses defined in this PP.<h:p/>
					</Guidance>
					<Tests>
						If the application "<h:i>implements asymmetric key generation</h:i>," then the following test
						activities shall be carried out. <h:p/>
						Evaluation Activity Note: The following tests may require the developer to provide access 
						to a developer environment that provides the evaluator with tools that are typically available
						to end-users of the application.<h:p/>
						<h:b>Key Generation for FIPS PUB 186-4 RSA Schemes</h:b><h:p/>
						The evaluator shall verify the implementation of RSA Key Generation by the 
						TOE using the Key Generation test. This test verifies the ability of 
						the TSF to correctly produce values for the key components including 
						the public verification exponent e, the private prime factors p and q, the public 
						modulus n and the calculation of the private signature exponent d. Key Pair generation 
						specifies 5 ways (or methods) to generate the primes p and q. 
						These include: <h:ol>
						<h:li>Random Primes:
							<h:ul>
								<h:li>Provable primes</h:li>
								<h:li>Probable primes</h:li>
							</h:ul>
						</h:li>
						<h:li>Primes with Conditions:
							<h:ul>
								<h:li>Primes p1, p2, q1,q2, p and q shall all be provable primes</h:li>
								<h:li>Primes p1, p2, q1, and q2 shall be provable primes and p and q shall be 
									probable primes</h:li>
								<h:li>Primes p1, p2, q1,q2, p and q shall all be probable primes</h:li>
							</h:ul>
						</h:li></h:ol>
						To test the key generation method for the Random Provable primes method and for all 
						the Primes with Conditions methods, the evaluator must seed the TSF 
						key generation routine with sufficient data to deterministically generate the RSA key 
						pair. This includes the random seed(s), the public exponent of the RSA key, and the 
						desired key length. For each key length supported, the evaluator shall have the 
						TSF generate 25 key pairs. The evaluator shall verify the 
						correctness of the TSF’s implementation by comparing values 
						generated by the TSF with those generated from a known good 
						implementation.<h:p/>
						If possible, the Random Probable primes method should also be verified against a 
						known good implementation as described above. Otherwise, the evaluator shall have 
						the TSF generate 10 keys pairs for each supported key length nlen 
						and verify: <h:ul>
							<h:li>n = p&#x22c5;q,</h:li>
							<h:li>p and q are probably prime according to Miller-Rabin tests,</h:li>
							<h:li>GCD(p-1,e) = 1,</h:li>
							<h:li>GCD(q-1,e) = 1,</h:li>
							<h:li>2<h:sup>16</h:sup> &#x2264; e &#x2264; 2<h:sup>256</h:sup> and e is an odd integer,</h:li>
							<h:li>|p-q| > 2<h:sup>nlen/2 - 100</h:sup>,</h:li>
							<h:li>p &#x2265; 2<h:sup>nlen/2 -1/2</h:sup>,</h:li>
							<h:li>q &#x2265; 2<h:sup>nlen/2 -1/2</h:sup>,</h:li>
							<h:li>2<h:sup>(nlen/2)</h:sup> &lt; d &lt; LCM(p-1,q-1),</h:li>
							<h:li>e&#x22c5;d = 1 mod LCM(p-1,q-1).</h:li>
						</h:ul>
						<h:b>Key Generation for Elliptic Curve Cryptography (ECC)</h:b><h:p/>
						FIPS 186-4 ECC Key Generation Test
						For each supported NIST curve, i.e., P-256, P-384 and P-521, the evaluator shall
						require the implementation under test (IUT) to generate 10 private/public key pairs.
						The private key shall be generated using an approved random bit generator (RBG). To 
						determine correctness, the evaluator shall submit the generated key pairs to the 
						public key verification (PKV) function of a known good implementation.<h:p/>
						FIPS 186-4 Public Key Verification (PKV) Test
						For each supported NIST curve, i.e., P-256, P-384 and P-521, the evaluator shall
						generate 10 private/public key pairs using the key generation function of a known 
						good implementation and modify five of the public key values so that they are 
						incorrect, leaving five values unchanged (i.e., correct). The evaluator shall obtain 
						in response a set of 10 PASS/FAIL values.<h:p/>
						<h:b>Key Generation for Finite-Field Cryptography (FFC)</h:b><h:p/>
						The evaluator shall verify the implementation of the Parameters Generation and the 
						Key Generation for FFC by the TOE using the Parameter Generation and 
						Key Generation test. This test verifies the ability of the TSF to 
						correctly produce values for the field prime p, the cryptographic prime q (dividing 
						p-1), the cryptographic group generator g, and the calculation of the private key x 
						and public key y. The Parameter generation specifies 2 ways (or methods) to generate 
						the cryptographic prime q and the field prime p:<h:p/>
						Cryptographic and Field Primes:	<h:ul>
							<h:li>Primes q and p shall both be provable primes</h:li>
							<h:li>Primes q and field prime p shall both be probable primes</h:li>
						</h:ul>
						and two ways to generate the cryptographic group generator g:<h:p/>
						Cryptographic Group Generator:
						<h:ul>
							<h:li>Generator g constructed through a verifiable process</h:li>
							<h:li>Generator g constructed through an unverifiable process.</h:li>
						</h:ul>
						The Key generation specifies 2 ways to generate the private key x:<h:p/>
						Private Key:
						<h:ul>
							<h:li>len(q) bit output of RBG where 1 &#x2264;x &#x2264; q-1</h:li>
							<h:li>len(q) + 64 bit output of RBG, followed by a mod q-1 operation where 
								1&#x2264; x&#x2264;q-1.</h:li>
						</h:ul>
						The security strength of the RBG must be at least that of the security offered by the 
						FFC parameter set.
						To test the cryptographic and field prime generation method for the provable primes 
						method and/or the group generator g for a verifiable process, the evaluator must seed 
						the TSF parameter generation routine with sufficient data to 
						deterministically generate the parameter set.
						For each key length supported, the evaluator shall have the TSF 
						generate 25 parameter sets and key pairs. The evaluator shall verify the correctness 
						of the TSF’s implementation by comparing values generated by the 
						TSF with those generated from a known good implementation. 
						Verification must also confirm
						<h:ul>
							<h:li>g &#8800; 0,1</h:li>
							<h:li>q divides p-1</h:li>
							<h:li>g<h:sup>q</h:sup> mod p = 1</h:li>
							<h:li>g<h:sup>x</h:sup> mod p = y</h:li>
						</h:ul>
						for each FFC parameter set and key pair. <h:p/>
						<h:b>Diffie-Hellman Group 14 and FFC Schemes using “safe-prime” groups</h:b><h:p/>
						Testing for FFC Schemes using Diffie-Hellman group 14 and/or safe-prime groups is done as part of testing
						in CKM.2.1.
					</Tests>
				</aactivity>
			</f-element>
		</change>
		
		<!-- FCS_CKM_EXT.1/PBKDF (formerly FCS_CKM.1/3) -->
		<!-- TD changed from FCS_CKM.1/PBKDF to FCS_CKM_EXT.1/PBKDF -->
		<change xpath=".//f-component[@id='fcom_pass']" mode="replace">
			<f-component name="Password Conditioning" cc-id="fcs_ckm_ext.1" id="fcom_pass_ext" iteration="PBKDF" status="sel-based">
				<depends on="sel-fcs-sto-pbkdf"/>
				<f-element id="fel-pass-ext">
					<title>
						A password/passphrase shall perform <assignable>Password-based Key Derivation Functions</assignable> 
						in accordance with a specified cryptographic algorithm as specified in FCS_COP.1/KeyedHash, with <assignable>positive 
						integer of 1,000 or more</assignable> iterations, and output cryptographic key sizes <selectables>
							<selectable>128</selectable>
							<selectable>256</selectable>
						</selectables>
						that meet the following <h:b>[NIST SP 800-132]</h:b>.  
					</title>
				</f-element>
				<f-element id="fel-gen-salts">
					<title>
						The TSF shall generate salts using a RBG that meets FCS_RBG_EXT.1 and with entropy corresponding
						to the security strength selected for PBKDF in FCS_CKM_EXT.1.1/PBKDF.
					</title>
					<note role="application">
						This should be included if selected in FCS_STO_EXT.1<h:p/>
						Conditioning can be performed using one of the identified hash functions or the process described 
						in NIST SP 800-132; the method used is selected by the ST Author. SP 800-132 requires the use of a pseudo-random 
						function (PRF) consisting of HMAC with an approved hash function. The ST author selects the hash function used, 
						also includes the appropriate requirements for HMAC and the hash function. <h:p/>
						Appendix A of SP 800-132 recommends setting the iteration count in order to increase the computation needed to derive a 
						key from a password and, therefore, increase the workload of performing a password recovery attack. A significantly higher 
						value is recommended to ensure optimal security. This value is expected to increase to a minimum of 10,000 in a future 
						iteration based on SP800-63.
					</note>
					<aactivity>
						<TSS> 
							Support for PBKDF: The evaluator shall examine the password hierarchy TSS to ensure that 
							the formation of all password based derived keys is described and that the key sizes match that 
							described by the ST author. 
							The evaluator shall check that the TSS describes the method by which the password/passphrase is first encoded and then fed to 
							the SHA algorithm. The settings for the algorithm (padding, blocking, etc.) shall be described, and the evaluator shall verify 
							that these are supported by the selections in this component as well as the selections concerning the hash function itself. 
							The evaluator shall verify that the TSS contains a description of how the output of the hash function is used to form the 
							submask that will be input into the function.
							For the NIST SP 800-132-based conditioning of the password/passphrase, the required evaluation activities will be performed when 
							doing the evaluation activities for the appropriate requirements (FCS_COP.1.1/KeyedHash).
							No explicit testing of the formation of the submask from the input password is required. 
							FCS_CKM_EXT.1.1/PBKDF: The ST author shall provide a description in the TSS regarding the salt generation. 
							The evaluator shall confirm that the salt is generated using an RBG described in FCS_RBG_EXT.1.<h:p/>
						</TSS>
						<Guidance>None.<h:p/></Guidance>
						<Tests>None.</Tests>
					</aactivity>
				</f-element>
			</f-component>	
		</change>

		<!-- FCS_CKM.2 -->
		<!-- TD updated reference in TSS to FCS_CKM.1.1/AK -->
		<change xpath=".//f-element[@id='fel-key-est']" mode="replace">	
			<f-element id="fel-key-est">
				<title>
					The application shall 
						<selectables onlyone="yes">
							<selectable>invoke platform-provided functionality</selectable>
							<selectable>implement functionality</selectable>
						</selectables> 
					to perform cryptographic key establishment in accordance with a specified 
					cryptographic key establishment method:<h:p/>
					<selectables linebreak="yes">	    
						<selectable>
							<h:b>[RSA-based key establishment schemes]</h:b> that meets the following: <h:b>[NIST 
							Special Publication 800-56B, “Recommendation for Pair-Wise Key Establishment 
							Schemes Using Integer Factorization Cryptography”]</h:b>
						</selectable>
						<selectable><h:b>[RSA-based key establishment schemes]</h:b>
							that meet the following: <h:b>RSAES-PKCS1-v1_5 as specified in Section 7.2 of RFC 8017,
							“Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1”</h:b>
						</selectable>
						<selectable>
							<h:b>[Elliptic curve-based key establishment schemes]</h:b> that meets the 
							following: <h:b>[NIST Special Publication 800-56A, “Recommendation for Pair-Wise Key Establishment 
							Schemes Using Discrete Logarithm Cryptography”]</h:b>
						</selectable>
						<selectable>
							<h:b>[Finite field-based key establishment schemes]</h:b> that meets the following: 
							<h:b>[NIST Special Publication 800-56A, “Recommendation for Pair-Wise Key 
							Establishment Schemes Using Discrete Logarithm Cryptography”]</h:b>
						</selectable>
						<selectable><h:b>[Key establishment scheme using Diffie-Hellman group 14]</h:b>
							that meets the following: <h:b>RFC 3526, Section 3</h:b>
						</selectable>
						<selectable><h:b>[FFC Schemes using “safe-prime” groups]</h:b>
							that meet the following: <h:b>‘NIST Special Publication 800-56A Revision 3,
							“Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography”</h:b>
							and <selectables>
								<selectable>RFC 3526</selectable>
								<selectable>RFC 7919</selectable>
							</selectables>.
						</selectable>
					</selectables>.
				</title>
				<note role="application">
					The ST author shall select all key establishment schemes used for the selected cryptographic 
					protocols. TLS requires cipher suites that use RSA-based key establishment 
					schemes. <h:p/>
					The RSA-based key establishment schemes are described in Section 9 of NIST SP 800-56B; 
					however, Section 9 relies on implementation of other sections in SP 800-56B. If the TOE acts 
					as a receiver in the RSA key establishment scheme, the TOE does not need to implement 
					RSA key generation.<h:p/>
					The elliptic curves used for the key establishment scheme shall correlate with the curves 
					specified in FCS_CKM.1.1/AK.<h:p/>
					The domain parameters used for the finite field-based key establishment scheme are specified 
					by the key generation according to FCS_CKM.1.1/AK.
				</note>
				<aactivity level="element">
					<TSS>
						The evaluator shall ensure that the supported key establishment schemes correspond to the 
						key generation schemes identified in FCS_CKM.1.1/AK. If the ST specifies more than one 
						scheme, the evaluator shall examine the TSS to verify that it identifies the usage for each 
						scheme.<h:p/>
					</TSS>
					<Guidance> 
						The evaluator shall verify that the AGD guidance instructs the administrator how to configure 
						the TOE to use the selected key establishment scheme(s).  <h:p/>  
					</Guidance>
					<Tests>
						Evaluation Activity Note: The following tests require the developer to provide access to a test 
						platform that provides the evaluator with tools that are typically not found on factory 
						products. <h:p/>
						<h:b>Key Establishment Schemes</h:b><h:p/>
						The evaluator shall verify the implementation of the key establishment schemes supported by 
						the TOE using the applicable tests below. <h:p/>
						<h:b>SP800-56A Key Establishment Schemes</h:b><h:p/>
						The evaluator shall verify a TOE's implementation of SP800-56A key agreement schemes 
						using the following Function and Validity tests. These validation tests for each key agreement 
						scheme verify that a TOE has implemented the components of the key agreement scheme 
						according to the specifications in the Recommendation. These components include the 
						calculation of the DLC primitives (the shared secret value Z) and the calculation of the 
						derived keying material (DKM) via the Key Derivation Function (KDF). If key confirmation 
						is supported, the evaluator shall also verify that the components of key confirmation have 
						been implemented correctly, using the test procedures described below. This includes the 
						parsing of the DKM, the generation of MACdata and the calculation of MACtag. <h:p/>
						<h:b>Function Test</h:b><h:p/>
						The Function test verifies the ability of the TOE to implement the key agreement 
						schemes correctly. To conduct this test the evaluator shall generate or obtain test vectors 
						from a known good implementation of the TOE supported schemes. For each supported 
						key agreement scheme-key agreement role combination, KDF type, and, if supported, 
						key confirmation role- key confirmation type combination, the tester shall generate 10 
						sets of test vectors. The data set consists of one set of domain parameter values (FFC) or 
						the NIST approved curve (ECC) per 10 sets of public keys. These keys are static, 
						ephemeral or both depending on the scheme being tested.<h:p/>
						The evaluator shall obtain the DKM, the corresponding TOE’s public keys (static and/or 
						ephemeral), the MAC tag(s), and any inputs used in the KDF, such as the Other 
						Information <h:i>(OtherInfo)</h:i> and TOE id fields. <h:p/>
						If the TOE does not use a KDF defined in SP 800-56A, the evaluator shall obtain only 
						the public keys and the hashed value of the shared secret.<h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation of a given 
						scheme by using a known good implementation to calculate the shared secret value, 
						derive the keying material DKM, and compare hashes or MAC tags generated from 
						these values. <h:p/>
						If key confirmation is supported, the TSF shall perform the above for each implemented 
						approved MAC algorithm. <h:p/>
						<h:b>Validity Test</h:b><h:p/>
						The Validity test verifies the ability of the TOE to recognize another party’s valid and 
						invalid key agreement results with or without key confirmation. To conduct this test, the 
						evaluator shall obtain a list of the supporting cryptographic functions included in the 
						SP800-56A key agreement implementation to determine which errors the TOE should 
						be able to recognize. The evaluator generates a set of 24 (FFC) or 30 (ECC) test vectors 
						consisting of data sets including domain parameter values or NIST approved curves, the 
						evaluator’s public keys, the TOE’s public/private key pairs, MACTag, and any inputs 
						used in the KDF, such as the OtherInfo and TOE id fields. <h:p/>
						The evaluator shall inject an error in some of the test vectors to test that the TOE 
						recognizes invalid key agreement results caused by the following fields being incorrect: 
						the shared secret value Z, the DKM, the OtherInfo field, the data to be 
						MACed, or the generated MACTag. If the TOE contains the full or partial (only ECC) 
						public key validation, the evaluator will also individually inject errors in both parties’ 
						static public keys, both parties’ ephemeral public keys and the TOE’s static private key 
						to assure the TOE detects errors in the public key validation function and/or the partial 
						key validation function (in ECC only). At least two of the test vectors shall remain 
						unmodified and therefore should result in valid key agreement results (they should pass).<h:p/>
						The TOE shall use these modified test vectors to emulate the key agreement scheme 
						using the corresponding parameters. The evaluator shall compare the TOE’s results with 
						the results using a known good implementation verifying that the TOE detects these errors.<h:p/>
						<h:b>SP800-56B Key Establishment Schemes</h:b><h:p/>
						The evaluator shall verify that the TSS describes whether the TOE acts as a sender, a 
						recipient, or both for RSA-based key establishment schemes. <h:p/>
						If the TOE acts as a sender, the following evaluation activity shall be performed to ensure the 
						proper operation of every TOE supported combination of RSA-based key establishment scheme: <h:p/>
						<h:div class="indent">
							To conduct this test the evaluator shall generate or obtain test vectors from a known 
							good implementation of the TOE supported schemes. For each combination of 
							supported key establishment scheme and its options (with or without key confirmation 
							if supported, for each supported key confirmation MAC function if key confirmation 
							is supported, and for each supported mask generation function if KTS-OAEP is 
							supported), the tester shall generate 10 sets of test vectors. Each test vector shall 
							include the RSA public key, the plaintext keying material, any additional input 
							parameters if applicable, the MacKey and MacTag if key confirmation is 
							incorporated, and the outputted ciphertext. For each test vector, the evaluator shall 
							perform a key establishment encryption operation on the TOE with the same inputs 
							(in cases where key confirmation is incorporated, the test shall use the MacKey from 
							the test vector instead of the randomly generated MacKey used in normal operation) 
							and ensure that the outputted ciphertext is equivalent to the ciphertext in the test vector.
						</h:div><h:p/>
						If the TOE acts as a receiver, the following evaluation activities shall be performed to ensure 
						the proper operation of every TOE supported combination of RSA-based key establishment scheme:<h:p/>
						<h:div class="indent">
							To conduct this test the evaluator shall generate or obtain test vectors from a known 
							good implementation of the TOE supported schemes. For each combination of 
							supported key establishment scheme and its options (with our without key 
							confirmation if supported, for each supported key confirmation MAC function if key 
							confirmation is supported, and for each supported mask generation function if KTS-OAEP is 
							supported), the tester shall generate 10 sets of test vectors. Each test vector 
							shall include the RSA private key, the plaintext keying material (KeyData), any 
							additional input parameters if applicable, the MacTag in cases where key 
							confirmation is incorporated, and the outputted ciphertext. For each test vector, the 
							evaluator shall perform the key establishment decryption operation on the TOE and 
							ensure that the outputted plaintext keying material (KeyData) is equivalent to the 
							plaintext keying material in the test vector. In cases where key confirmation is 
							incorporated, the evaluator shall perform the key confirmation steps and ensure that 
							the outputted MacTag is equivalent to the MacTag in the test vector.
						</h:div> <h:p/>
						The evaluator shall ensure that the TSS describes how the TOE handles decryption errors. In 
						accordance with NIST Special Publication 800-56B, the TOE must not reveal the particular 
						error that occurred, either through the contents of any outputted or logged error message or 
						through timing variations. If KTS-OAEP is supported, the evaluator shall create separate 
						contrived ciphertext values that trigger each of the three decryption error checks described in 
						NIST Special Publication 800-56B section 7.2.2.3, ensure that each decryption attempt 
						results in an error, and ensure that any outputted or logged error message is identical for each. 
						If KTS-KEM-KWS is supported, the evaluator shall create separate contrived ciphertext 
						values that trigger each of the three decryption error checks described in NIST Special 
						Publication 800-56B section 7.2.3.3, ensure that each decryption attempt results in an error, 
						and ensure that any outputted or logged error message is identical for each.<h:p/>
						<h:b>RSA-based key establishment</h:b><h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation of RSAES-PKCS1-v1_5 by using a
						known good implementation for each protocol selected in FTP_DIT_EXT.1 that uses RSAES-PKCS1-v1_5.  <h:p/>
						<h:b>Diffie-Hellman Group 14</h:b><h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation of Diffie-Hellman group 14 by using
						a known good implementation for each protocol selected in FTP_DIT_EXT.1 that uses Diffie-Hellman group 14.<h:p/>
						<h:b>FFC Schemes using “safe-prime” groups</h:b><h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation of safe-prime groups by using a
						known good implementation for each protocol selected in FTP_DIT_EXT.1 that uses safe-prime groups. This test
						must be performed for each safe-prime group that each protocol uses.
					</Tests>
				</aactivity>
			</f-element>
		</change>
		
	    <!-- FCS_COP.1/Hash (formerly FCS_COP.1/2) -->
		<!-- TD made formatting changes -->
		<change xpath=".//f-element[@id='fel-crypt-hash']" mode="replace">	
 			<f-element id="fel-crypt-hash">
				<title>
					The <h:b>application</h:b> shall perform [<h:i>cryptographic hashing services</h:i>] in accordance with a specified 
					cryptographic algorithm 
					<selectables linebreak="yes">
						<selectable>SHA-1</selectable>
						<selectable>SHA-256</selectable>
						<selectable>SHA-384</selectable>
						<selectable>SHA-512</selectable>
						<selectable exclusive="yes">no other</selectable>
					</selectables>
					and <h:b>message digest</h:b> sizes <selectables linebreak="yes">
						<selectable>160</selectable>
						<selectable>256</selectable>
						<selectable>384</selectable>
						<selectable>512</selectable>
						<selectable exclusive="yes">no other</selectable>
					</selectables> <h:b>bits</h:b> that meet the following: [FIPS Pub 180-4].
				</title>
				<note role="application">
					This is dependent on implementing cryptographic functionality, as in FTP_DIT_EXT.1.<h:p/>
					Per NIST SP 800-131A, SHA-1 for generating digital signatures is no
					longer allowed, and SHA-1 for verification of digital signatures is strongly discouraged as
					there may be risk in accepting these signatures.<h:p/>
					SHA-1 is currently included in order to comply with the TLS. If
					the TLS package is included in the ST, the hashing algorithms selection for FCS_COP.1/Hash
					must match the hashing algorithms used in the mandatory and selected cipher suites of
					the TLS package. Vendors are strongly encouraged to implement updated protocols that
					support the SHA-2 family; until updated protocols are supported, this PP allows support for
					SHA-1 implementations in compliance with SP 800-131A.<h:p/>
					The intent of this requirement is to specify the hashing function. The hash selection must
					support the message digest size selection. The hash selection should be consistent with the
					overall strength of the algorithm used (for example, SHA 256 for 128-bit keys).
				</note>
				<aactivity>
					<TSS>
						The evaluator shall check that the association of the hash function with other
						application cryptographic functions (for example, the digital signature verification
						function) is documented in the TSS.<h:p/>
					</TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						The TSF hashing functions can be implemented in one of two 
						modes. The first mode is the byte-oriented mode. In this mode the TSF 
						hashes only messages that are an integral number of bytes in length; i.e., the length 
						(in bits) of the message to be hashed is divisible by 8. The second mode is the 
						bit-oriented mode. In this mode the TSF hashes messages of arbitrary 
						length. As there are different tests for each mode, an indication is given in the 
						following sections for the bit-oriented vs. the byte-oriented test MACs. The evaluator 
						shall perform all of the following tests for each hash algorithm implemented by the 
						TSF and used to satisfy the requirements of this PP.<h:p/>     
						The following tests require the developer to provide access to a test application
						that provides the evaluator with tools that are typically not found in the production application.
						<testlist>
							<test>Short Messages Test - Bit oriented Mode. The evaluators devise an input set
								consisting of m+1 messages, where m is the block length of the hash algorithm. The
								length of the messages range sequentially from 0 to m bits. The message text shall
								be pseudorandomly generated. The evaluators compute the message digest for each of
								the messages and ensure that the correct result is produced when the messages are
								provided to the TSF. </test>
							<test>Short Messages Test - Byte oriented Mode. The evaluators devise an input set
								consisting of m/8+1 messages, where m is the block length of the hash algorithm.
								The length of the messages range sequentially from 0 to m/8 bytes, with each
								message being an integral number of bytes. The message text shall be
								pseudorandomly generated. The evaluators compute the message digest for each of
								the messages and ensure that the correct result is produced when the messages are
								provided to the TSF. </test>
							<test>Selected Long Messages Test - Bit oriented Mode. The evaluators devise an input
								set consisting of m messages, where m is the block length of the hash algorithm.
								The length of the ith message is 512 + 99*i, where 1 ≤ i ≤ m. The message text
								shall be pseudorandomly generated. The evaluators compute the message digest for
								each of the messages and ensure that the correct result is produced when the
								messages are provided to the TSF. </test>
							<test>Selected Long Messages Test - Byte oriented Mode. The evaluators devise an
								input set consisting of m/8 messages, where m is the block length of the hash
								algorithm. The length of the ith message is 512 + 8*99*i, where 1 ≤ i ≤ m/8. The
								message text shall be pseudorandomly generated. The evaluators compute the message
								digest for each of the messages and ensure that the correct result is produced
								when the messages are provided to the TSF. </test>
							<test>Pseudorandomly Generated Messages Test. This test is for byte-oriented
								implementations only. The evaluators randomly generate a seed that is n bits long,
								where n is the length of the message digest produced by the hash function to be
								tested. The evaluators then formulate a set of 100 messages and associated digests
								by following the algorithm provided in Figure 1 of [SHAVS]. The evaluators then
								ensure that the correct result is produced when the messages are provided to the
								TSF. </test>
						</testlist>
					</Tests>
				</aactivity>
			</f-element>
        </change> 

		<!-- FCS_COP.1/KeyedHash -->
		<!-- TD archived TD0626 and added formatting changes -->
       <change xpath=".//f-element[@id='fel-keyed-hash']" mode="replace">
			<f-element id="fel-keyed-hash">
				<title>The <h:b>application</h:b> shall perform [<h:i>keyed-hash message authentication</h:i>] in accordance with a 
					specified cryptographic algorithm
					<selectables linebreak="yes">
						<selectable>HMAC-SHA-256</selectable>
						<selectable>HMAC-SHA-384</selectable>
						<selectable>HMAC-SHA-512</selectable>
					</selectables> and
					<selectables linebreak="yes">
						<selectable>HMAC-SHA-1</selectable>
						<selectable exclusive="yes">no other algorithms</selectable>
					</selectables> <h:b>with</h:b> key sizes <assignable>key size (in bits) used in HMAC</assignable> 
					<h:b>and message digest sizes</h:b> 
					<selectables linebreak="yes">
						<selectable>256</selectable>
						<selectable>384</selectable>
						<selectable>512</selectable>
					</selectables> <h:b>and</h:b> 
					<selectables linebreak="yes">
						<selectable>160</selectable>
						<selectable exclusive="yes">no other size</selectable>
					</selectables>
					<h:b>bits</h:b> that meet the following: [<h:i>FIPS Pub 198-1, 'The Keyed-Hash Message Authentication Code'
					and FIPS Pub 180-4 'Secure Hash Standard</h:i>'].
				</title>
				<note role="application">
					This is dependent on implementing cryptographic functionality, as in FTP_DIT_EXT.1.<h:p/>
					The intent of this requirement is to specify the keyed-hash
					message authentication function used for key
					establishment purposes for the various cryptographic protocols
					used by the application (e.g., trusted channel). The hash selection must
					support the message digest size selection. The hash selection
					should be consistent with the overall strength of the algorithm used for FCS_COP.1/SKC.
				</note>
				<aactivity>
					The evaluator shall perform the following activities based on the selections in the ST.
					<TSS>None.<h:p/></TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						For each of the supported parameter sets, the evaluator shall compose 15 sets of test data.
						Each set shall consist of a key and message data.  The evaluator shall have the TSF generate
						HMAC tags for these sets of test data.  The resulting MAC tags shall be compared to the 
						result of generating HMAC tags with the same key and IV using a known-good implementation.
					</Tests>
				</aactivity>
			</f-element>
		</change>

	    <!-- FCS_COP.1/Sig (formerly FCS_COP.1/3) -->
		<!-- TD added formatting changes -->
       <change xpath=".//f-element[@id='fel-sign']" mode="replace">
			<f-element id="fel-sign">
				<title>
					The <h:b>application</h:b> shall perform [<h:i>cryptographic signature services (generation and
					verification)</h:i>] in accordance with a specified cryptographic algorithm <selectables linebreak="yes">
						<selectable><h:i><h:b>RSA schemes</h:b></h:i> using cryptographic key sizes of [2048-bit or greater] that meet the 
							following: [FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Section 5]</selectable>
						<selectable><h:b>ECDSA schemes</h:b> using [“NIST curves” P-256, P-384 and <selectables>
							<selectable>P-521</selectable>
							<selectable exclusive="yes">no other curves]</selectable></selectables>
						that meet the following: [FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Section 6]</selectable>
					</selectables>.
				</title>
				<note role="application">
					This is dependent on implementing cryptographic functionality, as in FTP_DIT_EXT.1.<h:p/>
					The ST Author should choose the algorithm implemented to perform
					digital signatures; if more than one algorithm is available, this requirement should be iterated
					to specify the functionality. For the algorithm chosen, the ST author should make the
					appropriate assignments/selections to specify the parameters that are implemented for that
					algorithm.
				</note>
				<aactivity>
					The evaluator shall perform the following activities based on the selections in the ST.
					<TSS>None.<h:p/></TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						The following tests require the developer to provide access to a test application
						that provides the evaluator with tools that are typically not found in the production
						application. <h:p/>
						ECDSA Algorithm Tests
						<testlist>
							<test>ECDSA FIPS 186-4 Signature Generation Test. For each
								supported NIST curve (i.e., P-256, P-384 and P-521) and SHA function pair, the
								evaluator shall generate 10 1024-bit long messages and obtain for each message a
								public key and the resulting signature values R and S. To determine correctness,
								the evaluator shall use the signature verification function of a known good
								implementation. 
							</test>
							<test>
								ECDSA FIPS 186-4 Signature Verification Test. For each supported
								NIST curve (i.e., P-256, P-384 and P-521) and SHA function pair, the evaluator
								shall generate a set of 10 1024-bit message, public key and signature tuples and
								modify one of the values (message, public key or signature) in five of the 10
								tuples. The evaluator shall obtain in response a set of 10 PASS/FAIL values.
							</test>
						</testlist>
						RSA Signature Algorithm Tests
						<testlist>
							<test>Signature Generation Test. The evaluator shall
								verify the implementation of RSA Signature Generation by the TOE
								using the Signature Generation Test. To conduct this test the evaluator must 
								generate or obtain 10 messages from a trusted reference implementation for each 
								modulus size/SHA combination supported by the TSF. The evaluator 
								shall have the TOE use their private key and modulus value to 
								sign these messages. The evaluator shall verify the correctness of the 
								TSF’s signature using a known good implementation and the 
								associated public keys to verify the signatures.
							</test>
							<test>Signature Verification Test. The 
								evaluator shall perform the Signature Verification test to verify the ability of 
								the TOE to recognize another party’s valid and invalid 
								signatures. The evaluator shall inject errors into the test vectors produced 
								during the Signature Verification Test by introducing errors in some of the public 
								keys, e, messages, IR format, and/or signatures. The TOE attempts 
								to verify the signatures and returns success or failure.
							</test>
						</testlist>
					</Tests>
				</aactivity>
			</f-element>
		</change>
		
		<!-- FCS_COP.1/SKC (formerly FCS_COP.1/1) Symmetric-Key Cryptography -->
		<!-- TD added formatting changes only -->
		<change xpath=".//f-element[@id='fel-sym-encrypt']" mode="replace">
			<f-element id="fel-sym-encrypt">
				<title>
					The <h:b>application</h:b> shall perform [<h:i>encryption/decryption</h:i>] in accordance with a specified 
					cryptographic algorithm  
					<selectables linebreak="yes">
						<selectable>AES-CBC (as defined in NIST SP 800-38A) mode</selectable>
						<selectable>AES-GCM (as defined in NIST SP 800-38D) mode</selectable>
						<selectable>AES-XTS (as defined in NIST SP 800-38E) mode</selectable>
						<selectable>AES-CCM (as defined in NIST SP 800-38C) mode</selectable>
						<selectable>AES-CTR (as defined in NIST SP 800-38A) mode</selectable>
					</selectables>
					and cryptographic key sizes 
					<selectables>
						<selectable>128-bit</selectable>
						<selectable>256-bit</selectable>
					</selectables>.
				</title>
				<note role="application">
					This is dependent on implementing cryptographic functionality, as in FTP_DIT_EXT.1.<h:br/>
					For the first selection, the ST author should choose
					the mode or modes in which AES operates. For the second selection, the ST author should
					choose the key sizes that are supported by this functionality. 128-bit key size 
					is required in order to comply with certain TLS implementations.<h:p/>
				</note>
				<aactivity>
					<TSS>None.<h:p/></TSS>
					<Guidance> 
						The evaluator checks the AGD documents to determine that any configuration that 
						is required to be done to configure the functionality for the required modes
						and key sizes is present.<h:p/>
					</Guidance>
					<Tests>
						The evaluator shall perform all of the following tests for each algorithm implemented by the TSF and used to
						satisfy the requirements of this PP:<h:p/>
						<h:b>AES-CBC Known Answer Tests</h:b><h:p/>
						There are four Known Answer Tests (KATs), described below. In all KATs, the plaintext, ciphertext, and IV values shall be 128-bit
						blocks. The results from each test may either be obtained by the
						evaluator directly or by supplying the inputs to the implementer
						and receiving the results in response. To determine correctness,
						the evaluator shall compare the resulting values to those obtained
						by submitting the same inputs to a known good implementation. <h:ul>
							<h:li>KAT-1. To test the encrypt functionality of AES-CBC, the
								evaluator shall supply a set of 10 plaintext values and obtain
								the ciphertext value that results from AES-CBC encryption of the
								given plaintext using a key value of all zeros and an IV of all
								zeros. Five plaintext values shall be encrypted with a 128-bit
								all-zeros key, and the other five shall be encrypted with a
								256-bit all- zeros key. To test the decrypt functionality of
								AES-CBC, the evaluator shall perform the same test as for
								encrypt, using 10 ciphertext values as input and AES-CBC
								decryption.</h:li>
							<h:li>KAT-2. To test the encrypt functionality of AES-CBC, the
								evaluator shall supply a set of 10 key values and obtain the
								ciphertext value that results from AES-CBC encryption of an
								all-zeros plaintext using the given key value and an IV of all
								zeros. Five of the keys shall be 128-bit keys, and the other five
								shall be 256-bit keys. To test the decrypt functionality of
								AES-CBC, the evaluator shall perform the same test as for
								encrypt, using an all-zero ciphertext value as input and AES-CBC
								decryption.</h:li>
							<h:li>KAT-3. To test the encrypt functionality of AES-CBC, the
								evaluator shall supply the two sets of key values described below
								and obtain the ciphertext value that results from AES encryption
								of an all-zeros plaintext using the given key value and an IV of
								all zeros. The first set of keys shall have 128 128-bit keys, and
								the second set shall have 256 256-bit keys. Key i in each set
								shall have the leftmost i bits be ones and the rightmost N-i bits
								be zeros, for i in [1,N]. To test the decrypt functionality of
								AES-CBC, the evaluator shall supply the two sets of key and
								ciphertext value pairs described below and obtain the plaintext
								value that results from AES-CBC decryption of the given
								ciphertext using the given key and an IV of all zeros. The first
								set of key/ciphertext pairs shall have 128 128-bit key/ciphertext
								pairs, and the second set of key/ciphertext pairs shall have 256
								256-bit key/ciphertext pairs. Key i in each set shall have the
								leftmost i bits be ones and the rightmost N-i bits be zeros, for
								i in [1,N]. The ciphertext value in each pair shall be the value
								that results in an all-zeros plaintext when decrypted with its
								corresponding key.</h:li>
							<h:li>KAT-4. To test the encrypt functionality of AES-CBC, the
								evaluator shall supply the set of 128 plaintext values described
								below and obtain the two ciphertext values that result from
								AES-CBC encryption of the given plaintext using a 128-bit key
								value of all zeros with an IV of all zeros and using a 256-bit
								key value of all zeros with an IV of all zeros, respectively.
								Plaintext value i in each set shall have the leftmost i bits be
								ones and the rightmost 128-i bits be zeros, for i in
								[1,128].</h:li>
						</h:ul>To test the decrypt functionality of AES-CBC, the evaluator
						shall perform the same test as for encrypt, using ciphertext values
						of the same form as the plaintext in the encrypt test as input and
						AES-CBC decryption. <h:p/>
						<h:b>AES-CBC Multi-Block Message Test</h:b><h:p/>
						The evaluator shall test the encrypt functionality by
						encrypting an i-block message where 1 &lt; i &lt;= 10. The
						evaluator shall choose a key, an IV and plaintext message of length
						i blocks and encrypt the message, using the mode to be tested, with
						the chosen key and IV. The ciphertext shall be compared to the
						result of encrypting the same plaintext message with the same key
						and IV using a known good implementation. The evaluator shall also
						test the decrypt functionality for each mode by decrypting an
						i-block message where 1 &lt; i &lt;=10. The evaluator shall choose
						a key, an IV and a ciphertext message of length i blocks and
						decrypt the message, using the mode to be tested, with the chosen
						key and IV. The plaintext shall be compared to the result of
						decrypting the same ciphertext message with the same key and IV
						using a known good implementation. AES-CBC Monte Carlo Tests The
						evaluator shall test the encrypt functionality using a set of 200
						plaintext, IV, and key 3- tuples. 100 of these shall use 128 bit
						keys, and 100 shall use 256 bit keys. The plaintext and IV values
						shall be 128-bit blocks. For each 3-tuple, 1000 iterations shall be
						run as follows: 
						  <h:pre>
						  # Input: PT, IV, Key
						  for i = 1 to 1000:
							if i == 1:
								  CT[1] = AES-CBC-Encrypt(Key, IV, PT)
								  PT = IV
							else:
							  CT[i] = AES-CBC-Encrypt(Key, PT) 
							  PT = CT[i-1]
						  </h:pre>
						The ciphertext computed in the 1000th iteration (i.e.,
						CT[1000]) is the result for that trial. This result shall be
						compared to the result of running 1000 iterations with the same
						values using a known good implementation.<h:p/>
						The evaluator shall test the decrypt functionality using the
						same test as for encrypt, exchanging CT and PT and replacing
						AES-CBC-Encrypt with AES-CBC-Decrypt. <h:p/>
						<h:b>AES-GCM Monte Carlo Tests</h:b><h:p/>
						The evaluator shall test the authenticated encrypt
						functionality of AES-GCM for each combination of the following
						input parameter lengths: <h:ul>
							<h:li>128 bit and 256 bit keys</h:li>
							<h:li>Two plaintext lengths. One of the plaintext lengths shall be
								a non-zero integer multiple of 128 bits, if
								supported. The other plaintext length shall not be an integer
								multiple of 128 bits, if supported.</h:li>
							<h:li>Three AAD lengths. One AAD length shall be 0, if supported.
								One AAD length shall be a non-zero integer
								multiple of 128 bits, if supported. One AAD length shall not be
								an integer multiple of 128 bits, if supported.</h:li>
							<h:li>Two IV lengths. If 96 bit IV is supported, 96 bits shall be
								one of the two IV lengths tested.</h:li>
						</h:ul>The evaluator shall test the encrypt functionality using a set
						of 10 key, plaintext, AAD, and IV tuples for each combination of
						parameter lengths above and obtain the ciphertext value and tag
						that results from AES-GCM authenticated encrypt. Each supported tag
						length shall be tested at least once per set of 10. The IV value
						may be supplied by the evaluator or the implementation being
						tested, as long as it is known. <h:p/>
						The evaluator shall test the decrypt functionality using a
						set of 10 key, ciphertext, tag, AAD, and IV 5-tuples for each
						combination of parameter lengths above and obtain a Pass/Fail
						result on authentication and the decrypted plaintext if Pass. The
						set shall include five tuples that Pass and five that Fail.<h:p/>
						The results from each test may either be obtained by the
						evaluator directly or by supplying the inputs to the implementer
						and receiving the results in response. To determine correctness,
						the evaluator shall compare the resulting values to those obtained
						by submitting the same inputs to a known good
						implementation.<h:p/>
						<h:b>AES-XTS Tests</h:b><h:p/>
						The evaluator shall test the encrypt functionality of XTS-AES for each combination
						of the following input parameter lengths:<h:p/>
						256 bit (for AES-128) and 512 bit (for AES-256) keys<h:p/>
						Three data unit (i.e., plaintext) lengths. One of the data unit lengths shall be a
						non-zero integer multiple of 128 bits, if supported. One of the data unit lengths
						shall be an integer multiple of 128 bits, if supported. The third data unit length
						shall be either the longest supported data unit length or 216 bits, whichever is
						smaller.<h:p/>
						Using a set of 100 (key, plaintext and 128-bit random tweak value) 3-tuples and
						obtain the ciphertext that results from XTS-AES encrypt.<h:p/>
						The evaluator may supply a data unit sequence number instead of the tweak value if
						the implementation supports it. The data unit sequence number is a base-10 number
						ranging between 0 and 255 that implementations convert to a tweak value internally.<h:p/>
						The evaluator shall test the decrypt functionality of XTS-AES using the same test as
						for encrypt, replacing plaintext values with ciphertext values and XTS-AES encrypt
						with XTS-AES decrypt.<h:p/>
						<h:b>AES-CCM Tests</h:b>
						It is not recommended that evaluators use values obtained from static sources such as
						http://csrc.nist.gov/groups/STM/cavp/documents/mac/ccmtestvectors.zip or use values not generated expressly
						to exercise the AES-CCM implementation.<h:p/>
						The evaluator shall test the generation-encryption and decryption-verification functionality of AES-CCM for
						the following input parameter and tag lengths:<h:ul>
							<h:li>Keys: All supported and selected key sizes (e.g., 128, 256 bits).</h:li>
							<h:li>Associated Data: Two or three values for associated data length: The minimum (≥ 0 bytes) and 
								maximum (≤ 32 bytes) supported associated data lengths, and 2^16 (65536) bytes, if supported.</h:li>
							<h:li>Payload: Two values for payload length: The minimum (≥ 0 bytes) and maximum (≤ 32 bytes) supported 
								payload lengths.</h:li>
							<h:li>Nonces: All supported nonce lengths (7, 8, 9, 10, 11, 12, 13) in bytes.</h:li>
							<h:li>Tag: All supported tag lengths (4, 6, 8, 10, 12, 14, 16) in bytes.</h:li>
						</h:ul>
						The testing for CCM consists of five tests. To determine correctness in each of the below tests, the evaluator
						shall compare the ciphertext with the result of encryption of the same inputs with a known good implementation.<h:p/>
						<h:b>Variable Associated Data Test</h:b><h:p/>
						For each supported key size and associated data length, and any supported payload length, nonce length, and tag 
						length, the evaluator shall supply one key value, one nonce value, and 10 pairs of associated data and payload 
						values, and obtain the resulting ciphertext.<h:p/>
						<h:b>Variable Payload Test</h:b><h:p/>
						For each supported key size and payload length, and any supported associated data length, nonce length, and tag 
						length, the evaluator shall supply one key value, one nonce value, and 10 pairs of associated data and payload 
						values, and obtain the resulting ciphertext.<h:p/>
						<h:b>Variable Nonce Test</h:b><h:p/>
						For each supported key size and nonce length, and any supported associated data length, payload length, and tag 
						length, the evaluator shall supply one key value, one nonce value, and 10 pairs of associated data and payload
						values, and obtain the resulting ciphertext.<h:p/>
						<h:b>Variable Tag Test</h:b><h:p/>
						For each supported key size and tag length, and any supported associated data length, payload length, and nonce 
						length, the evaluator shall supply one key value, one nonce value, and 10 pairs of associated data and payload 
						values, and obtain the resulting ciphertext.<h:p/>
						<h:b>Decryption-Verification Process Test</h:b><h:p/>
						To test the decryption-verification functionality of AES-CCM, for each combination of supported associated data
						length, payload length, nonce length, and tag length, the evaluator shall supply a key value and 15 sets of input 
						plus ciphertext, and obtain the decrypted payload. Ten of the 15 input sets supplied should fail verification and
						five should pass.<h:p/>
						<h:b>AES-CTR Tests</h:b><h:p/>
						<h:b><h:i>Test 1: Known Answer Tests (KATs)</h:i></h:b><h:p/>
						There are four Known Answer Tests (KATs) described below. For all KATs, the plaintext, IV, and ciphertext values 
						shall be 128-bit blocks. The results from each test may either be obtained by the validator directly or by
						supplying the inputs to the implementer and receiving the results in response. To determine correctness, the 
						evaluator shall compare the resulting values to those obtained by submitting the same inputs to a known good
						implementation.<h:p/>
						To test the encrypt functionality, the evaluator shall supply a set of 10 plaintext values and obtain the
						ciphertext value that results from encryption of the given plaintext using a key value of all zeros and an IV of
						all zeros. Five plaintext values shall be encrypted with a 128-bit all zeros key, and the other five shall be 
						encrypted with a 256-bit all zeros key. To test the decrypt functionality, the evaluator shall perform the same 
						test as for encrypt, using 10 ciphertext values as input.<h:p/>
						To test the encrypt functionality, the evaluator shall supply a set of 10 key values and obtain the ciphertext 
						value that results from encryption of an all zeros plaintext using the given key value and an IV of all zeros.
						Five of the key values shall be 128-bit keys, and the other five shall be 256-bit keys. To test the decrypt 
						functionality, the evaluator shall perform the same test as for encrypt, using an all zero ciphertext value as 
						input.<h:p/>
						To test the encrypt functionality, the evaluator shall supply the two sets of key values described below and 
						obtain the ciphertext values that result from AES encryption of an all zeros plaintext using the given key values
						an an IV of all zeros. The first set of keys shall have 128 128-bit keys, and the second shall have 256 256-bit 
						keys. Key_i in each set shall have the leftmost i bits be ones and the rightmost N-i bits be zeros, for i
						in [1, N]. To test the decrypt functionality, the evaluator shall supply the two sets of key and ciphertext
						value pairs described below and obtain the plaintext value that results from decryption of the given ciphertext
						using the given key values and an IV of all zeros. The first set of key/ciphertext pairs shall have 128 128-bit
						key/ciphertext pairs, and the second set of key/ciphertext pairs shall have 256 256-bit pairs. Key_i in each
						set shall have the leftmost i bits be ones and the rightmost N-i bits be zeros for i in [1, N]. The ciphertext
						value in each pair shall be the value that results in an all zeros plaintext when decrypted with its corresponding
						key.<h:p/>
						To test the encrypt functionality, the evaluator shall supply the set of 128 plaintext values described below and 
						obtain the two ciphertext values that result from encryption of the given plaintext using a 128-bit key value of 
						all zeros and using a 256 bit key value of all zeros, respectively, and an IV of all zeros. Plaintext value i in
						each set shall have the leftmost bits be ones and the rightmost 128-i bits be zeros, for i in [1, 128]. To test
						the decrypt functionality, the evaluator shall perform the same test as for encrypt, using ciphertext values of
						the same form as the plaintext in the encrypt test as input.<h:p/>
						<h:b><h:i>Test 2: Multi-Block Message Test</h:i></h:b><h:p/>
						The evaluator shall test the encrypt functionality by encrypting an i-block message where 1 less-than i 
						less-than-or-equal to 10. For each i the evaluator shall choose a key, IV, and plaintext message of length i 
						blocks and encrypt the message, using the mode to be tested, with the chosen key. The ciphertext shall be compared 
						to the result of encrypting the same plaintext message with the same key and IV using a known good implementation.
						The evaluator shall also test the decrypt functionality by decrypting an i-block message where 1 less-than i 
						less-than-or-equal to 10. For each i the evaluator shall choose a key and a ciphertext message of length i blocks 
						and decrypt the message, using the mode to be tested, with the chosen key. The plaintext shall be compared to the
						result of decrypting the same ciphertext message with the same key using a known good implementation.<h:p/>
						<h:b><h:i>Test 3: Monte-Carlo Test</h:i></h:b><h:p/>
						For AES-CTR mode perform the Monte Carlo Test for ECB Mode on the encryption engine of the counter mode
						implementation. There is no need to test the decryption engine.<h:p/>
						The evaluator shall test the encrypt functionality using 200 plaintext/key pairs. 100 of these shall use 128 bit 
						keys, and 100 of these shall use 256 bit keys. The plaintext values shall be 128-bit blocks. For each pair, 
						1000 iterations shall be run as follows:<h:p/>
						<h:code>
							For AES-ECB mode
							   # Input: PT, Key              
							   for i = 1 to 1000:
								  CT[i] = AES-ECB-Encrypt(Key, PT)
								  PT = CT[i]
						</h:code><h:p/>
						The ciphertext computed in the 1000th iteration is the result for that trial. This result shall be compared to
						the result of running 1000 iterations with the same values using a known good implementation.<h:p/>
					</Tests>
				</aactivity>
			</f-element>
		      </change>
    </decision>
  </bunch>
</technical-decisions>
