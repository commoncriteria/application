<?xml version="1.0" encoding="utf-8"?>
<technical-decisions  xmlns:h="http://www.w3.org/1999/xhtml" 
		      xmlns="https://niap-ccevs.org/cc/v1">
  <bunch>
    <applies-to max-inclusive="1.4" name="Protection Profile for Application Software"/>

    <decision id='0655'>
	<!-- This TD also affects the XML code for include-pkg, FCS_CKM.2, FCS_COP.1/SKC, FCS_COP.1/Hash, FCS_COP.1/KeyedHash, FCS_COP.1/Sign, FIA_X509_EXT.1, FIA_X509_EXT.2 -->
    	<notes>Mutual authentication in FTP_DIT_EXT.1 for SW App - NOTE: In addition to modifying FTP_DIT_EXT.1 SFR text and App Notes, this TD modifies the relationships for multiple SFRs, without impacting the presented SFR, App Note, or EA text. </notes>
		
		<!-- FTP_DIT_EXT.1 -->
        <change xpath=".//f-element[@id='fel-transmit']" mode="replace">
		<f-element id="fel-transmit">
				<title>The application shall 
					<selectables linebreak="yes">
						<selectable exclusive="yes">not transmit any 
							<selectables>
								<selectable exclusive="yes">data</selectable>
								<selectable exclusive="yes">sensitive data</selectable>
							</selectables>
						</selectable>
						<selectable exclusive="yes">encrypt all transmitted 
							<selectables>
								<selectable exclusive="yes">sensitive data</selectable>
								<selectable exclusive="yes">data</selectable>
							</selectables> with
							<selectables>
								<selectable id="sel_all_https_cl">HTTPS as a client in accordance with FCS_HTTPS_EXT.1/Client</selectable>
								<selectable id="sel_all_https_sv">HTTPS as a server in accordance with FCS_HTTPS_EXT.1/Server</selectable>
								<selectable id="sel_all_https_ma">HTTPS as a server using mutual authentication in accordance with FCS_HTTPS_EXT.2</selectable>
								<!-- 8/3/22 WAS:
								<selectable id="sel_all_tls">TLS as defined in the <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=439&amp;id=439"><h:i>Functional Package for TLS</h:i></h:a></selectable>
								<selectable id="sel_all_dtls">DTLS as defined in the <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=439&amp;id=439"><h:i>Functional Package for TLS</h:i></h:a></selectable>
								-->
								
								<selectable id="sel_all_tls_cl">TLS as a client as defined in the <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=439&amp;id=439"><h:i>Functional Package for TLS</h:i></h:a></selectable>
								<selectable id="sel_all_tls_sv">TLS as a server as defined in the <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=439&amp;id=439"><h:i>Functional Package for TLS</h:i></h:a> and also supports functionality for
									<selectables>
										<selectable exclusive="yes" id="sel_all_tls_sv_ma">mutual authentication</selectable>
										<selectable exclusive="yes" id="sel_all_tls_sv_none">none</selectable>
									</selectables>
								</selectable>
								<selectable id="sel_all_dtls_cl">DTLS as a client as defined in the <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=439&amp;id=439"><h:i>Functional Package for TLS</h:i></h:a></selectable>
								<selectable id="sel_all_dtls_sv">DTLS as a server as defined in the <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=439&amp;id=439"><h:i>Functional Package for TLS</h:i></h:a> and also supports functionality for
									<selectables>
										<selectable exclusive="yes" id="sel_all_dtls_sv_ma">mutual authentication</selectable>
										<selectable exclusive="yes" id="sel_all_dtls_sv_none">none</selectable>
									</selectables>
								</selectable>
								<selectable id="sel_all_ssh">SSH as defined in the <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=459&amp;id=459"><h:i>Functional Package for Secure Shell</h:i></h:a></selectable>
								<!-- 8/3/22: added id for IPsec -->
								<selectable id="sel_all_ipsec">IPsec as defined in the <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=419&amp;id=419"><h:i>PP-Module for VPN Client</h:i></h:a></selectable>
							</selectables>
						</selectable>
						<selectable exclusive="yes">invoke platform-provided functionality to encrypt all transmitted sensitive data with
						<!-- 2/1/23: Added ids -->
							<selectables>
								<selectable id="sel_enc_sens_https">HTTPS</selectable>
								<selectable id="sel_enc_sens_tls">TLS</selectable>
								<selectable id="sel_enc_sens_dtls">DTLS</selectable>
								<selectable id="sel_enc_sens_ssh">SSH</selectable>
							</selectables>
						</selectable>						
						<selectable exclusive="yes">invoke platform-provided functionality to encrypt all transmitted data with
						<!-- 2/1/23: Added ids -->
							<selectables>
								<selectable id="sel_enc_data_https">HTTPS</selectable>
								<selectable id="sel_enc_data_tls">TLS</selectable>
								<selectable id="sel_enc_data_dtls">DTLS</selectable>
								<selectable id="sel_enc_data_ssh">SSH</selectable>
							</selectables>
						</selectable>	    	    
					</selectables> between itself and another trusted IT product.
				</title>
				<note role="application">
					<!--The X509 requirements are invoked based on the selections in FTP_DIT_EXT.1; if you select a protocol that uses certificates,
					then you must include the SFRs that address the certificates.   
					X509 SFRs shall be included if selections for HTTPS, TLS, or DTLS are included (FCS_HTTPS, FCS_TLSC, FCS_TLSS, FCS_DTLS).
					<h:br/> <h:br/>-->
					Encryption is not required for applications transmitting data that is not sensitive.<h:p/>
					<!-- 8/3/22 WAS: 
					If "<h:i>encrypt all transmitted</h:i>" is selected and "<h:i>TLS</h:i>" is selected, then 
					evaluation of elements from either FCS_TLSC_EXT.1 or FCS_TLSS_EXT.1 is required.<h:p/>
					-->
					If "<h:i>encrypt all transmitted</h:i>" is selected and "<h:i>TLS</h:i>" or "<h:i>DTLS</h:i>" as a client/server is selected, then 
					corresponding elements from the Functional Package for TLS must be selected.<h:p/>
					If "<h:i>encrypt all transmitted</h:i>" is selected, "<h:i>HTTPS</h:i>" is selected, and the 
					TOE acts as a client, then FCS_HTTPS_EXT.1/Client is required.<h:p/> 
					If "<h:i>encrypt all transmitted</h:i>" is selected, "<h:i>HTTPS</h:i>" is selected, and the 
					TOE acts as a server, then FCS_HTTPS_EXT.1/Server is required. <h:p/> 
					<!-- If the TOE acts as a server and if mutual authentication is selected in the TLS Package, 
					then FCS_HTTPS_EXT.2 is also required.  -->
					<!-- 8/3/22: Removed "in the TLS Package" -->
					If the TOE acts as a server and if "<h:i>mutual authentication</h:i>" is selected,
					then FCS_HTTPS_EXT.2 is also required. <h:p/> 
					<!-- 8/3/22: WAS:
					If "<h:i>encrypt all transmitted</h:i>" is selected and "<h:i>DTLS</h:i>" is selected, then
					FCS_DTLS_EXT.1 is required.<h:p/>
					-->
					If "<h:i>encrypt all transmitted</h:i>" is selected and "<h:i>SSH</h:i>" is selected, then the 
					TSF shall be validated against the  <h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=459&amp;id=459">
					<h:i>Functional Package for Secure Shell</h:i></h:a>.<h:p/>
					If "<h:i>encrypt all transmitted</h:i>" is selected and "<h:i>IPsec</h:i>" is selected, then the
					TSF must claim conformance to a <h:i>PP-Configuration that includes the
					<h:a href="https://www.niap-ccevs.org/Profile/Info.cfm?PPID=461&amp;id=461">
					VPN Client PP-Module</h:a></h:i><h:p/>
					If "<h:i>encrypt all transmitted</h:i>" is selected the corresponding FCS_COP.1 
					requirements will be included.<h:p/>
					In addition to the above, FIA_X509_EXT.1 and FIA_X509_EXT.2 are required when the following is 
					true:<h:ul>
						<h:li>"<h:i>encrypt all transmitted</h:i>" is selected and the TOE implements a protocol that requires 
							certificates</h:li>
						<h:li>"<h:i>invoke platform-provided functionality to encrypt all transmitted sensitive data</h:i>" is 
							selected and the platform implements a protocol that requires certificates</h:li>
						<h:li>"<h:i>invoke platform-provided functionality to encrypt all transmitted data</h:i>" is selected 
							and the platform implements a protocol that requires certificates</h:li></h:ul>
						<!--  8/3/22 WAS:
						<h:b>Note:</h:b>FIA_X509_EXT.1 and FIA_X509_EXT.2 are not applicable when the TOE acts 
						as a HTTPS/TLS server with no mutual authentication.
						-->
						<h:b>Note:</h:b>FIA_X509_EXT.1 and FIA_X509_EXT.2 are not applicable when the TOE acts 
						as a HTTPS/(D)TLS server.
						<!-- 8/3/22 ADDED -->
						The selections for mutual authentication for HTTPS align with the selections in this SFR. The selections for 
						mutual authentication must match the corresponding requirements in the Functional Package for TLS.
				</note>  
				<aactivity>
					<TSS>
						For platform-provided functionality, the evaluator shall verify the TSS contains 
						the calls to the platform that TOE is leveraging to invoke the functionality.<h:p/>
					</TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						The evaluator shall perform the following tests.
						<testlist>
							<test>
								 The evaluator shall exercise the application (attempting to transmit data; for 
								 example by connecting to remote systems or websites) while capturing packets from 
								 the application. The evaluator shall verify from the packet capture that the
								 traffic is encrypted with HTTPS, TLS, DTLS, SSH, or IPsec in accordance with the
								 selection in the ST.
							</test>
							<test>
								The evaluator shall exercise the application (attempting to transmit data; for
								example by connecting to remote systems or websites) while capturing packets from 
								the application. The evaluator shall review the packet capture and verify that no 
								sensitive data is transmitted in the clear.
							</test>
							<test>
								The evaluator shall inspect the TSS to determine if user credentials are transmitted.
								If credentials are transmitted the evaluator shall set the credential to a known
								value. The evaluator shall capture packets from the application while causing
								credentials to be transmitted as described in the TSS. The evaluator shall perform
								a string search of the captured network packets and verify that the plaintext
								credential previously set by the evaluator is not found.
							</test>
						</testlist>
						<h:div><depends ref="android"/>
							If "not transmit any data" is selected, the evaluator shall ensure that the application's 
							AndroidManifest.xml file does not contain a uses-permission or uses-permission-sdk-23 tag 
							containing android:name="android.permission.INTERNET". In this case, it is not necessary to perform 
							the above Tests 1, 2, or 3, as the platform will not allow the application to perform any network 
							communication.
							<!-- TODO: The current wording here adds additional work when "encrypt all transmitted data"
						   is selected. It'd be preferable if we can instead simplify evaluation in that case, to encourage
						   app developers to select it, so this is commented out for now.
						   If "encrypt all transmitted data" is selected, the evaluator
						   shall ensure that the application's manifest declares usesCleartextTraffic="false". It is
						   still necessary to perform the above tests, as this manifest entry is only enforced on
						   a best effort basis by the platform. -->
						</h:div>
						<h:div><depends ref="ios"/>
							If "encrypt all transmitted data" is selected, the evaluator shall ensure that the application's
							Info.plist file does not contain the NSAllowsArbitraryLoads or 
							NSExceptionAllowsInsecureHTTPLoads keys, as these keys disable iOS's Application 
							Transport Security feature.
							<!-- TODO: Check the strength of iOS's App Transport Security enforcement (if apps
							can't easily bypass it, then we can skip performing Tests 1, 2, 3 on iOS when
							App Transport Security isn't explicitly disabled (assuming use of iOS 9 or greater)). -->
						</h:div>
					</Tests>
				</aactivity>
			</f-element>
		</change>
		
		<!-- TLS package inclusion -->
		<change xpath=".//include-pkg[@id='pkg-tls']" mode="replace">
		   <include-pkg id="pkg-tls">
				<raw-url>https://raw.githubusercontent.com/commoncriteria/tls/v1.1/input/tls.xml</raw-url>
				<url>https://www.niap-ccevs.org/Profile/Info.cfm?PPID=439&amp;id=439</url>
				<!-- 8/3/22 WAS: <depends on-sel="sel_all_tls" on-also="sel_all_dtls"/>  -->
				<!-- 2/3/23 WAS: <depends on-sel1="sel_all_tls_cl" on-sel2="sel_all_tls_sv" on-sel3="sel_all_dtls_cl" on-asel4="sel_all_dtls_sv"/> -->
				<depends onsel1="sel_all_https_cl" onsel2="sel_all_https_sv" onsel3="sel_all_https_ma" onsel4="sel_all_tls_cl" onsel5="sel_all_tls_sv" onsel6="sel_all_dtls_cl" onsel7="sel_all_dtls_sv"/>
			</include-pkg>
		</change>
		
		<!-- FCS_CKM.2-->
		<change xpath=".//f-component[@cc-id='fcs_ckm.2']" mode="replace">
		   <f-component cc-id="fcs_ckm.2" name="Cryptographic Key Establishment" status="sel-based">
			<!-- 8/3/22 WAS: <depends on="sel_all_tls"/> -->
			<!-- 1/25/23 WAS: <depends on1="sel_all_tls_cl" on2="sel_all_tls_sv"/> -->
			<!-- 2/1/23: Added HTTPS, IPsec, DTLS, and SSH IDs -->
			<depends on1="sel_all_https_cl" on2="sel_all_https_sv"  on3="sel_all_https_ma" on4="sel_all_ipsec" on5="sel_all_ssh" on6="sel_all_tls_cl" on7="sel_all_tls_sv" on8="sel_all_dtls_cl" on9="sel_all_dtls_sv"/>
			<f-element id="fel-key-est">
				<title>
					The application shall 
						<selectables onlyone="yes">
							<selectable>invoke platform-provided functionality</selectable>
							<selectable>implement functionality</selectable>
						</selectables> 
					to perform cryptographic key establishment in accordance with a specified 
					cryptographic key establishment method:<h:p/>
					<selectables linebreak="yes">	    
						<selectable>
							<h:b>[RSA-based key establishment schemes]</h:b> that meets the following: <h:b>[NIST 
							Special Publication 800-56B, “Recommendation for Pair-Wise Key Establishment 
							Schemes Using Integer Factorization Cryptography”]</h:b>
						</selectable>
						<selectable><h:b>[RSA-based key establishment schemes]</h:b>
							that meet the following: <h:b>RSAES-PKCS1-v1_5 as specified in Section 7.2 of RFC 8017,
							“Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography Specifications Version 2.1”</h:b>
						</selectable>
						<selectable>
							<h:b>[Elliptic curve-based key establishment schemes]</h:b> that meets the 
							following: <h:b>[NIST Special Publication 800-56A, “Recommendation for Pair-Wise Key Establishment 
							Schemes Using Discrete Logarithm Cryptography”]</h:b>
						</selectable>
						<selectable>
							<h:b>[Finite field-based key establishment schemes]</h:b> that meets the following: 
							<h:b>[NIST Special Publication 800-56A, “Recommendation for Pair-Wise Key 
							Establishment Schemes Using Discrete Logarithm Cryptography”]</h:b>
						</selectable>
						<selectable><h:b>[Key establishment scheme using Diffie-Hellman group 14]</h:b>
							that meets the following: <h:b>RFC 3526, Section 3</h:b>
						</selectable>
						<selectable><h:b>[FFC Schemes using “safe-prime” groups]</h:b>
							that meet the following: <h:b>‘NIST Special Publication 800-56A Revision 3,
							“Recommendation for Pair-Wise Key Establishment Schemes Using Discrete Logarithm Cryptography”</h:b>
							and <selectables>
								<selectable>RFC 3526</selectable>
								<selectable>RFC 7919</selectable>
							</selectables>.
						</selectable>
					</selectables>.
				</title>
				<note role="application">
					The ST author shall select all key establishment schemes used for the selected cryptographic 
					protocols. TLS requires cipher suites that use RSA-based key establishment 
					schemes. <h:p/>
					The RSA-based key establishment schemes are described in Section 9 of NIST SP 800-56B; 
					however, Section 9 relies on implementation of other sections in SP 800-56B. If the TOE acts 
					as a receiver in the RSA key establishment scheme, the TOE does not need to implement 
					RSA key generation.<h:p/>
					The elliptic curves used for the key establishment scheme shall correlate with the curves 
					specified in FCS_CKM.1.1/AK.<h:p/>
					The domain parameters used for the finite field-based key establishment scheme are specified 
					by the key generation according to FCS_CKM.1.1/AK.
				</note>
				<aactivity level="element">
					<TSS>
						The evaluator shall ensure that the supported key establishment schemes correspond to the 
						key generation schemes identified in FCS_CKM.1.1. If the ST specifies more than one 
						scheme, the evaluator shall examine the TSS to verify that it identifies the usage for each 
						scheme.<h:p/>
					</TSS>
					<Guidance> 
						The evaluator shall verify that the AGD guidance instructs the administrator how to configure 
						the TOE to use the selected key establishment scheme(s).  <h:p/>  
					</Guidance>
					<Tests>
						Evaluation Activity Note: The following tests require the developer to provide access to a test 
						platform that provides the evaluator with tools that are typically not found on factory 
						products. <h:p/>
						<h:b>Key Establishment Schemes</h:b><h:p/>
						The evaluator shall verify the implementation of the key establishment schemes supported by 
						the TOE using the applicable tests below. <h:p/>
						<h:b>SP800-56A Key Establishment Schemes</h:b><h:p/>
						The evaluator shall verify a TOE's implementation of SP800-56A key agreement schemes 
						using the following Function and Validity tests. These validation tests for each key agreement 
						scheme verify that a TOE has implemented the components of the key agreement scheme 
						according to the specifications in the Recommendation. These components include the 
						calculation of the DLC primitives (the shared secret value Z) and the calculation of the 
						derived keying material (DKM) via the Key Derivation Function (KDF). If key confirmation 
						is supported, the evaluator shall also verify that the components of key confirmation have 
						been implemented correctly, using the test procedures described below. This includes the 
						parsing of the DKM, the generation of MACdata and the calculation of MACtag. <h:p/>
						<h:b>Function Test</h:b><h:p/>
						The Function test verifies the ability of the TOE to implement the key agreement 
						schemes correctly. To conduct this test the evaluator shall generate or obtain test vectors 
						from a known good implementation of the TOE supported schemes. For each supported 
						key agreement scheme-key agreement role combination, KDF type, and, if supported, 
						key confirmation role- key confirmation type combination, the tester shall generate 10 
						sets of test vectors. The data set consists of one set of domain parameter values (FFC) or 
						the NIST approved curve (ECC) per 10 sets of public keys. These keys are static, 
						ephemeral or both depending on the scheme being tested.<h:p/>
						The evaluator shall obtain the DKM, the corresponding TOE’s public keys (static and/or 
						ephemeral), the MAC tag(s), and any inputs used in the KDF, such as the Other 
						Information <h:i>(OtherInfo)</h:i> and TOE id fields. <h:p/>
						If the TOE does not use a KDF defined in SP 800-56A, the evaluator shall obtain only 
						the public keys and the hashed value of the shared secret.<h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation of a given 
						scheme by using a known good implementation to calculate the shared secret value, 
						derive the keying material DKM, and compare hashes or MAC tags generated from 
						these values. <h:p/>
						If key confirmation is supported, the TSF shall perform the above for each implemented 
						approved MAC algorithm. <h:p/>
						<h:b>Validity Test</h:b><h:p/>
						The Validity test verifies the ability of the TOE to recognize another party’s valid and 
						invalid key agreement results with or without key confirmation. To conduct this test, the 
						evaluator shall obtain a list of the supporting cryptographic functions included in the 
						SP800-56A key agreement implementation to determine which errors the TOE should 
						be able to recognize. The evaluator generates a set of 24 (FFC) or 30 (ECC) test vectors 
						consisting of data sets including domain parameter values or NIST approved curves, the 
						evaluator’s public keys, the TOE’s public/private key pairs, MACTag, and any inputs 
						used in the KDF, such as the OtherInfo and TOE id fields. <h:p/>
						The evaluator shall inject an error in some of the test vectors to test that the TOE 
						recognizes invalid key agreement results caused by the following fields being incorrect: 
						the shared secret value Z, the DKM, the OtherInfo field, the data to be 
						MACed, or the generated MACTag. If the TOE contains the full or partial (only ECC) 
						public key validation, the evaluator will also individually inject errors in both parties’ 
						static public keys, both parties’ ephemeral public keys and the TOE’s static private key 
						to assure the TOE detects errors in the public key validation function and/or the partial 
						key validation function (in ECC only). At least two of the test vectors shall remain 
						unmodified and therefore should result in valid key agreement results (they should pass).<h:p/>
						The TOE shall use these modified test vectors to emulate the key agreement scheme 
						using the corresponding parameters. The evaluator shall compare the TOE’s results with 
						the results using a known good implementation verifying that the TOE detects these errors.<h:p/>
						<h:b>SP800-56B Key Establishment Schemes</h:b><h:p/>
						The evaluator shall verify that the TSS describes whether the TOE acts as a sender, a 
						recipient, or both for RSA-based key establishment schemes. <h:p/>
						If the TOE acts as a sender, the following evaluation activity shall be performed to ensure the 
						proper operation of every TOE supported combination of RSA-based key establishment scheme: <h:p/>
						<h:div class="indent">
							To conduct this test the evaluator shall generate or obtain test vectors from a known 
							good implementation of the TOE supported schemes. For each combination of 
							supported key establishment scheme and its options (with or without key confirmation 
							if supported, for each supported key confirmation MAC function if key confirmation 
							is supported, and for each supported mask generation function if KTS-OAEP is 
							supported), the tester shall generate 10 sets of test vectors. Each test vector shall 
							include the RSA public key, the plaintext keying material, any additional input 
							parameters if applicable, the MacKey and MacTag if key confirmation is 
							incorporated, and the outputted ciphertext. For each test vector, the evaluator shall 
							perform a key establishment encryption operation on the TOE with the same inputs 
							(in cases where key confirmation is incorporated, the test shall use the MacKey from 
							the test vector instead of the randomly generated MacKey used in normal operation) 
							and ensure that the outputted ciphertext is equivalent to the ciphertext in the test vector.
						</h:div><h:p/>
						If the TOE acts as a receiver, the following evaluation activities shall be performed to ensure 
						the proper operation of every TOE supported combination of RSA-based key establishment scheme:<h:p/>
						<h:div class="indent">
							To conduct this test the evaluator shall generate or obtain test vectors from a known 
							good implementation of the TOE supported schemes. For each combination of 
							supported key establishment scheme and its options (with our without key 
							confirmation if supported, for each supported key confirmation MAC function if key 
							confirmation is supported, and for each supported mask generation function if KTS-OAEP is 
							supported), the tester shall generate 10 sets of test vectors. Each test vector 
							shall include the RSA private key, the plaintext keying material (KeyData), any 
							additional input parameters if applicable, the MacTag in cases where key 
							confirmation is incorporated, and the outputted ciphertext. For each test vector, the 
							evaluator shall perform the key establishment decryption operation on the TOE and 
							ensure that the outputted plaintext keying material (KeyData) is equivalent to the 
							plaintext keying material in the test vector. In cases where key confirmation is 
							incorporated, the evaluator shall perform the key confirmation steps and ensure that 
							the outputted MacTag is equivalent to the MacTag in the test vector.
						</h:div> <h:p/>
						The evaluator shall ensure that the TSS describes how the TOE handles decryption errors. In 
						accordance with NIST Special Publication 800-56B, the TOE must not reveal the particular 
						error that occurred, either through the contents of any outputted or logged error message or 
						through timing variations. If KTS-OAEP is supported, the evaluator shall create separate 
						contrived ciphertext values that trigger each of the three decryption error checks described in 
						NIST Special Publication 800-56B section 7.2.2.3, ensure that each decryption attempt 
						results in an error, and ensure that any outputted or logged error message is identical for each. 
						If KTS-KEM-KWS is supported, the evaluator shall create separate contrived ciphertext 
						values that trigger each of the three decryption error checks described in NIST Special 
						Publication 800-56B section 7.2.3.3, ensure that each decryption attempt results in an error, 
						and ensure that any outputted or logged error message is identical for each.<h:p/>
						<h:b>RSA-based key establishment</h:b><h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation of RSAES-PKCS1-v1_5 by using a
						known good implementation for each protocol selected in FTP_DIT_EXT.1 that uses RSAES-PKCS1-v1_5.  <h:p/>
						<h:b>Diffie-Hellman Group 14</h:b><h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation of Diffie-Hellman group 14 by using
						a known good implementation for each protocol selected in FTP_DIT_EXT.1 that uses Diffie-Hellman group 14.<h:p/>
						<h:b>FFC Schemes using “safe-prime” groups</h:b><h:p/>
						The evaluator shall verify the correctness of the TSF’s implementation of safe-prime groups by using a
						known good implementation for each protocol selected in FTP_DIT_EXT.1 that uses safe-prime groups. This test
						must be performed for each safe-prime group that each protocol uses.
					</Tests>
				</aactivity>
			</f-element>
        </f-component>
		</change>
		
		<!-- FCS_COP.1/SKC -->
		<change xpath=".//f-component[@id='fcom_crypto']" mode="replace">
			<f-component cc-id="fcs_cop.1" id="fcom_crypto" iteration="SKC" name="Cryptographic Operation - Encryption/Decryption" status="sel-based">
			<!-- 8/3/22 WAS: <depends on="sel_all_tls"/> -->
			<!-- 1/25/23 WAS: <depends on1="sel_all_tls_cl" on2="sel_all_tls_sv"/> -->
			<!-- 2/1/23: Added HTTPS, IPsec, DTLS, and SSH IDs -->
			<depends on1="sel_all_https_cl" on2="sel_all_https_sv"  on3="sel_all_https_ma" on4="sel_all_ipsec" on5="sel_all_ssh" on6="sel_all_tls_cl" on7="sel_all_tls_sv" on8="sel_all_dtls_cl" on9="sel_all_dtls_sv"/>
			<depends on="sel-fcs-sto-skc"/>
			<f-element id="fel-sym-encrypt">
				<title>
					The <h:b>application</h:b> shall perform <h:i>encryption/decryption</h:i> in accordance with a specified 
					cryptographic algorithm  
					<selectables linebreak="yes">
						<selectable>AES-CBC (as defined in NIST SP 800-38A) mode</selectable>
						<selectable>AES-GCM (as defined in NIST SP 800-38D) mode</selectable>
						<selectable>AES-XTS (as defined in NIST SP 800-38E) mode</selectable>
						<selectable>AES-CCM (as defined in NIST SP 800-38C) mode</selectable>
						<selectable>AES-CTR (as defined in NIST SP 800-38A) mode</selectable>
					</selectables>
					and cryptographic key sizes 
					<selectables>
						<selectable>128-bit</selectable>
						<selectable>256-bit</selectable>
					</selectables>.
				</title>
				<note role="application">
					This is dependent on implementing cryptographic functionality, as in FTP_DIT_EXT.1.<h:br/>
					For the first selection, the ST author should choose
					the mode or modes in which AES operates. For the second selection, the ST author should
					choose the key sizes that are supported by this functionality. 128-bit key size 
					is required in order to comply with certain TLS implementations.<h:p/>
				</note>
				<aactivity>
					<TSS>None.<h:p/></TSS>
					<Guidance> 
						The evaluator checks the AGD documents to determine that any configuration that 
						is required to be done to configure the functionality for the required modes
						and key sizes is present.<h:p/>
					</Guidance>
					<Tests>
						The evaluator shall perform all of the following tests for each algorithm implemented by the TSF and used to
						satisfy the requirements of this PP:<h:p/>
						<h:b>AES-CBC Known Answer Tests</h:b><h:p/>
						There are four Known Answer Tests (KATs), described below. In all KATs, the plaintext, ciphertext, and IV values shall be 128-bit
						blocks. The results from each test may either be obtained by the
						evaluator directly or by supplying the inputs to the implementer
						and receiving the results in response. To determine correctness,
						the evaluator shall compare the resulting values to those obtained
						by submitting the same inputs to a known good implementation. <h:ul>
							<h:li>KAT-1. To test the encrypt functionality of AES-CBC, the
								evaluator shall supply a set of 10 plaintext values and obtain
								the ciphertext value that results from AES-CBC encryption of the
								given plaintext using a key value of all zeros and an IV of all
								zeros. Five plaintext values shall be encrypted with a 128-bit
								all-zeros key, and the other five shall be encrypted with a
								256-bit all- zeros key. To test the decrypt functionality of
								AES-CBC, the evaluator shall perform the same test as for
								encrypt, using 10 ciphertext values as input and AES-CBC
								decryption.</h:li>
							<h:li>KAT-2. To test the encrypt functionality of AES-CBC, the
								evaluator shall supply a set of 10 key values and obtain the
								ciphertext value that results from AES-CBC encryption of an
								all-zeros plaintext using the given key value and an IV of all
								zeros. Five of the keys shall be 128-bit keys, and the other five
								shall be 256-bit keys. To test the decrypt functionality of
								AES-CBC, the evaluator shall perform the same test as for
								encrypt, using an all-zero ciphertext value as input and AES-CBC
								decryption.</h:li>
							<h:li>KAT-3. To test the encrypt functionality of AES-CBC, the
								evaluator shall supply the two sets of key values described below
								and obtain the ciphertext value that results from AES encryption
								of an all-zeros plaintext using the given key value and an IV of
								all zeros. The first set of keys shall have 128 128-bit keys, and
								the second set shall have 256 256-bit keys. Key i in each set
								shall have the leftmost i bits be ones and the rightmost N-i bits
								be zeros, for i in [1,N]. To test the decrypt functionality of
								AES-CBC, the evaluator shall supply the two sets of key and
								ciphertext value pairs described below and obtain the plaintext
								value that results from AES-CBC decryption of the given
								ciphertext using the given key and an IV of all zeros. The first
								set of key/ciphertext pairs shall have 128 128-bit key/ciphertext
								pairs, and the second set of key/ciphertext pairs shall have 256
								256-bit key/ciphertext pairs. Key i in each set shall have the
								leftmost i bits be ones and the rightmost N-i bits be zeros, for
								i in [1,N]. The ciphertext value in each pair shall be the value
								that results in an all-zeros plaintext when decrypted with its
								corresponding key.</h:li>
							<h:li>KAT-4. To test the encrypt functionality of AES-CBC, the
								evaluator shall supply the set of 128 plaintext values described
								below and obtain the two ciphertext values that result from
								AES-CBC encryption of the given plaintext using a 128-bit key
								value of all zeros with an IV of all zeros and using a 256-bit
								key value of all zeros with an IV of all zeros, respectively.
								Plaintext value i in each set shall have the leftmost i bits be
								ones and the rightmost 128-i bits be zeros, for i in
								[1,128].</h:li>
						</h:ul>To test the decrypt functionality of AES-CBC, the evaluator
						shall perform the same test as for encrypt, using ciphertext values
						of the same form as the plaintext in the encrypt test as input and
						AES-CBC decryption. <h:p/>
						<h:b>AES-CBC Multi-Block Message Test</h:b><h:p/>
						The evaluator shall test the encrypt functionality by
						encrypting an i-block message where 1 &lt; i &lt;= 10. The
						evaluator shall choose a key, an IV and plaintext message of length
						i blocks and encrypt the message, using the mode to be tested, with
						the chosen key and IV. The ciphertext shall be compared to the
						result of encrypting the same plaintext message with the same key
						and IV using a known good implementation. The evaluator shall also
						test the decrypt functionality for each mode by decrypting an
						i-block message where 1 &lt; i &lt;=10. The evaluator shall choose
						a key, an IV and a ciphertext message of length i blocks and
						decrypt the message, using the mode to be tested, with the chosen
						key and IV. The plaintext shall be compared to the result of
						decrypting the same ciphertext message with the same key and IV
						using a known good implementation. AES-CBC Monte Carlo Tests The
						evaluator shall test the encrypt functionality using a set of 200
						plaintext, IV, and key 3- tuples. 100 of these shall use 128 bit
						keys, and 100 shall use 256 bit keys. The plaintext and IV values
						shall be 128-bit blocks. For each 3-tuple, 1000 iterations shall be
						run as follows: 
						  <h:pre>
						  # Input: PT, IV, Key
						  for i = 1 to 1000:
							if i == 1:
								  CT[1] = AES-CBC-Encrypt(Key, IV, PT)
								  PT = IV
							else:
							  CT[i] = AES-CBC-Encrypt(Key, PT) 
							  PT = CT[i-1]
						  </h:pre>
						The ciphertext computed in the 1000th iteration (i.e.,
						CT[1000]) is the result for that trial. This result shall be
						compared to the result of running 1000 iterations with the same
						values using a known good implementation.<h:p/>
						The evaluator shall test the decrypt functionality using the
						same test as for encrypt, exchanging CT and PT and replacing
						AES-CBC-Encrypt with AES-CBC-Decrypt. <h:p/>
						<h:b>AES-GCM Monte Carlo Tests</h:b><h:p/>
						The evaluator shall test the authenticated encrypt
						functionality of AES-GCM for each combination of the following
						input parameter lengths: <h:ul>
							<h:li>128 bit and 256 bit keys</h:li>
							<h:li>Two plaintext lengths. One of the plaintext lengths shall be
								a non-zero integer multiple of 128 bits, if
								supported. The other plaintext length shall not be an integer
								multiple of 128 bits, if supported.</h:li>
							<h:li>Three AAD lengths. One AAD length shall be 0, if supported.
								One AAD length shall be a non-zero integer
								multiple of 128 bits, if supported. One AAD length shall not be
								an integer multiple of 128 bits, if supported.</h:li>
							<h:li>Two IV lengths. If 96 bit IV is supported, 96 bits shall be
								one of the two IV lengths tested.</h:li>
						</h:ul>The evaluator shall test the encrypt functionality using a set
						of 10 key, plaintext, AAD, and IV tuples for each combination of
						parameter lengths above and obtain the ciphertext value and tag
						that results from AES-GCM authenticated encrypt. Each supported tag
						length shall be tested at least once per set of 10. The IV value
						may be supplied by the evaluator or the implementation being
						tested, as long as it is known. <h:p/>
						The evaluator shall test the decrypt functionality using a
						set of 10 key, ciphertext, tag, AAD, and IV 5-tuples for each
						combination of parameter lengths above and obtain a Pass/Fail
						result on authentication and the decrypted plaintext if Pass. The
						set shall include five tuples that Pass and five that Fail.<h:p/>
						The results from each test may either be obtained by the
						evaluator directly or by supplying the inputs to the implementer
						and receiving the results in response. To determine correctness,
						the evaluator shall compare the resulting values to those obtained
						by submitting the same inputs to a known good
						implementation.<h:p/>
						<h:b>AES-XTS Tests</h:b><h:p/>
						The evaluator shall test the encrypt functionality of XTS-AES for each combination
						of the following input parameter lengths:<h:p/>
						256 bit (for AES-128) and 512 bit (for AES-256) keys<h:p/>
						Three data unit (i.e., plaintext) lengths. One of the data unit lengths shall be a
						non-zero integer multiple of 128 bits, if supported. One of the data unit lengths
						shall be an integer multiple of 128 bits, if supported. The third data unit length
						shall be either the longest supported data unit length or 216 bits, whichever is
						smaller.<h:p/>
						Using a set of 100 (key, plaintext and 128-bit random tweak value) 3-tuples and
						obtain the ciphertext that results from XTS-AES encrypt.<h:p/>
						The evaluator may supply a data unit sequence number instead of the tweak value if
						the implementation supports it. The data unit sequence number is a base-10 number
						ranging between 0 and 255 that implementations convert to a tweak value internally.<h:p/>
						The evaluator shall test the decrypt functionality of XTS-AES using the same test as
						for encrypt, replacing plaintext values with ciphertext values and XTS-AES encrypt
						with XTS-AES decrypt.<h:p/>
						<h:b>AES-CCM Tests</h:b>
						It is not recommended that evaluators use values obtained from static sources such as
						http://csrc.nist.gov/groups/STM/cavp/documents/mac/ccmtestvectors.zip or use values not generated expressly
						to exercise the AES-CCM implementation.<h:p/>
						The evaluator shall test the generation-encryption and decryption-verification functionality of AES-CCM for
						the following input parameter and tag lengths:<h:ul>
							<h:li>Keys: All supported and selected key sizes (e.g., 128, 256 bits).</h:li>
							<h:li>Associated Data: Two or three values for associated data length: The minimum (≥ 0 bytes) and 
								maximum (≤ 32 bytes) supported associated data lengths, and 2^16 (65536) bytes, if supported.</h:li>
							<h:li>Payload: Two values for payload length: The minimum (≥ 0 bytes) and maximum (≤ 32 bytes) supported 
								payload lengths.</h:li>
							<h:li>Nonces: All supported nonce lengths (7, 8, 9, 10, 11, 12, 13) in bytes.</h:li>
							<h:li>Tag: All supported tag lengths (4, 6, 8, 10, 12, 14, 16) in bytes.</h:li>
						</h:ul>
						The testing for CCM consists of five tests. To determine correctness in each of the below tests, the evaluator
						shall compare the ciphertext with the result of encryption of the same inputs with a known good implementation.<h:p/>
						<h:b>Variable Associated Data Test</h:b><h:p/>
						For each supported key size and associated data length, and any supported payload length, nonce length, and tag 
						length, the evaluator shall supply one key value, one nonce value, and 10 pairs of associated data and payload 
						values, and obtain the resulting ciphertext.<h:p/>
						<h:b>Variable Payload Test</h:b><h:p/>
						For each supported key size and payload length, and any supported associated data length, nonce length, and tag 
						length, the evaluator shall supply one key value, one nonce value, and 10 pairs of associated data and payload 
						values, and obtain the resulting ciphertext.<h:p/>
						<h:b>Variable Nonce Test</h:b><h:p/>
						For each supported key size and nonce length, and any supported associated data length, payload length, and tag 
						length, the evaluator shall supply one key value, one nonce value, and 10 pairs of associated data and payload
						values, and obtain the resulting ciphertext.<h:p/>
						<h:b>Variable Tag Test</h:b><h:p/>
						For each supported key size and tag length, and any supported associated data length, payload length, and nonce 
						length, the evaluator shall supply one key value, one nonce value, and 10 pairs of associated data and payload 
						values, and obtain the resulting ciphertext.<h:p/>
						<h:b>Decryption-Verification Process Test</h:b><h:p/>
						To test the decryption-verification functionality of AES-CCM, for each combination of supported associated data
						length, payload length, nonce length, and tag length, the evaluator shall supply a key value and 15 sets of input 
						plus ciphertext, and obtain the decrypted payload. Ten of the 15 input sets supplied should fail verification and
						five should pass.<h:p/>
						<h:b>AES-CTR Tests</h:b><h:p/>
						<h:b><h:i>Test 1: Known Answer Tests (KATs)</h:i></h:b><h:p/>
						There are four Known Answer Tests (KATs) described below. For all KATs, the plaintext, IV, and ciphertext values 
						shall be 128-bit blocks. The results from each test may either be obtained by the validator directly or by
						supplying the inputs to the implementer and receiving the results in response. To determine correctness, the 
						evaluator shall compare the resulting values to those obtained by submitting the same inputs to a known good
						implementation.<h:p/>
						To test the encrypt functionality, the evaluator shall supply a set of 10 plaintext values and obtain the
						ciphertext value that results from encryption of the given plaintext using a key value of all zeros and an IV of
						all zeros. Five plaintext values shall be encrypted with a 128-bit all zeros key, and the other five shall be 
						encrypted with a 256-bit all zeros key. To test the decrypt functionality, the evaluator shall perform the same 
						test as for encrypt, using 10 ciphertext values as input.<h:p/>
						To test the encrypt functionality, the evaluator shall supply a set of 10 key values and obtain the ciphertext 
						value that results from encryption of an all zeros plaintext using the given key value and an IV of all zeros.
						Five of the key values shall be 128-bit keys, and the other five shall be 256-bit keys. To test the decrypt 
						functionality, the evaluator shall perform the same test as for encrypt, using an all zero ciphertext value as 
						input.<h:p/>
						To test the encrypt functionality, the evaluator shall supply the two sets of key values described below and 
						obtain the ciphertext values that result from AES encryption of an all zeros plaintext using the given key values
						an an IV of all zeros. The first set of keys shall have 128 128-bit keys, and the second shall have 256 256-bit 
						keys. Key_i in each set shall have the leftmost i bits be ones and the rightmost N-i bits be zeros, for i
						in [1, N]. To test the decrypt functionality, the evaluator shall supply the two sets of key and ciphertext
						value pairs described below and obtain the plaintext value that results from decryption of the given ciphertext
						using the given key values and an IV of all zeros. The first set of key/ciphertext pairs shall have 128 128-bit
						key/ciphertext pairs, and the second set of key/ciphertext pairs shall have 256 256-bit pairs. Key_i in each
						set shall have the leftmost i bits be ones and the rightmost N-i bits be zeros for i in [1, N]. The ciphertext
						value in each pair shall be the value that results in an all zeros plaintext when decrypted with its corresponding
						key.<h:p/>
						To test the encrypt functionality, the evaluator shall supply the set of 128 plaintext values described below and 
						obtain the two ciphertext values that result from encryption of the given plaintext using a 128-bit key value of 
						all zeros and using a 256 bit key value of all zeros, respectively, and an IV of all zeros. Plaintext value i in
						each set shall have the leftmost bits be ones and the rightmost 128-i bits be zeros, for i in [1, 128]. To test
						the decrypt functionality, the evaluator shall perform the same test as for encrypt, using ciphertext values of
						the same form as the plaintext in the encrypt test as input.<h:p/>
						<h:b><h:i>Test 2: Multi-Block Message Test</h:i></h:b><h:p/>
						The evaluator shall test the encrypt functionality by encrypting an i-block message where 1 less-than i 
						less-than-or-equal to 10. For each i the evaluator shall choose a key, IV, and plaintext message of length i 
						blocks and encrypt the message, using the mode to be tested, with the chosen key. The ciphertext shall be compared 
						to the result of encrypting the same plaintext message with the same key and IV using a known good implementation.
						The evaluator shall also test the decrypt functionality by decrypting an i-block message where 1 less-than i 
						less-than-or-equal to 10. For each i the evaluator shall choose a key and a ciphertext message of length i blocks 
						and decrypt the message, using the mode to be tested, with the chosen key. The plaintext shall be compared to the
						result of decrypting the same ciphertext message with the same key using a known good implementation.<h:p/>
						<h:b><h:i>Test 3: Monte-Carlo Test</h:i></h:b><h:p/>
						For AES-CTR mode perform the Monte Carlo Test for ECB Mode on the encryption engine of the counter mode
						implementation. There is no need to test the decryption engine.<h:p/>
						The evaluator shall test the encrypt functionality using 200 plaintext/key pairs. 100 of these shall use 128 bit 
						keys, and 100 of these shall use 256 bit keys. The plaintext values shall be 128-bit blocks. For each pair, 
						1000 iterations shall be run as follows:<h:p/>
						<h:code>
							For AES-ECB mode
							   # Input: PT, Key              
							   for i = 1 to 1000:
								  CT[i] = AES-ECB-Encrypt(Key, PT)
								  PT = CT[i]
						</h:code><h:p/>
						The ciphertext computed in the 1000th iteration is the result for that trial. This result shall be compared to
						the result of running 1000 iterations with the same values using a known good implementation.<h:p/>
					</Tests>
				</aactivity>
			</f-element>
        </f-component> 
		</change>
		
		<!-- FCS_COP.1/Hash -->
		<change xpath=".//f-component[@id='fcom_hash']" mode="replace">
		   <f-component cc-id="fcs_cop.1" id="fcom_hash" iteration="Hash" name="Cryptographic Operation - Hashing" status="sel-based">
			<!-- 8/3/22 WAS: <depends on="sel_all_tls"/> -->
			<!-- 1/25/23 WAS: <depends on1="sel_all_tls_cl" on2="sel_all_tls_sv"/> -->
			<!-- 2/1/23: Added HTTPS, IPsec, DTLS, and SSH IDs -->
			<depends on1="sel_all_https_cl" on2="sel_all_https_sv"  on3="sel_all_https_ma" on4="sel_all_ipsec" on5="sel_all_ssh" on6="sel_all_tls_cl" on7="sel_all_tls_sv" on8="sel_all_dtls_cl" on9="sel_all_dtls_sv"/>
			<f-element id="fel-crypt-hash">
				<title>
					The <h:b>application</h:b> shall perform <h:i>cryptographic hashing</h:i> services in accordance with a specified 
					cryptographic algorithm 
					<selectables linebreak="yes">
						<selectable>SHA-1</selectable>
						<selectable>SHA-256</selectable>
						<selectable>SHA-384</selectable>
						<selectable>SHA-512</selectable>
						<selectable exclusive="yes">no other</selectable>
					</selectables>
					and message digest sizes <selectables linebreak="yes">
						<selectable>160</selectable>
						<selectable>256</selectable>
						<selectable>384</selectable>
						<selectable>512</selectable>
						<selectable exclusive="yes">no other</selectable>
					</selectables> bits that meet the following: FIPS Pub 180-4.
				</title>
				<note role="application">
					This is dependent on implementing cryptographic functionality, as in FTP_DIT_EXT.1.<h:p/>
					Per NIST SP 800-131A, SHA-1 for generating digital signatures is no
					longer allowed, and SHA-1 for verification of digital signatures is strongly discouraged as
					there may be risk in accepting these signatures.<h:p/>
					SHA-1 is currently included in order to comply with the TLS. If
					the TLS package is included in the ST, the hashing algorithms selection for FCS_COP.1/Hash
					must match the hashing algorithms used in the mandatory and selected cipher suites of
					the TLS package. Vendors are strongly encouraged to implement updated protocols that
					support the SHA-2 family; until updated protocols are supported, this PP allows support for
					SHA-1 implementations in compliance with SP 800-131A.<h:p/>
					The intent of this requirement is to specify the hashing function. The hash selection must
					support the message digest size selection. The hash selection should be consistent with the
					overall strength of the algorithm used (for example, SHA 256 for 128-bit keys).
				</note>
				<aactivity>
					<TSS>
						The evaluator shall check that the association of the hash function with other
						application cryptographic functions (for example, the digital signature verification
						function) is documented in the TSS.<h:p/>
					</TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						The TSF hashing functions can be implemented in one of two 
						modes. The first mode is the byte-oriented mode. In this mode the TSF 
						hashes only messages that are an integral number of bytes in length; i.e., the length 
						(in bits) of the message to be hashed is divisible by 8. The second mode is the 
						bit-oriented mode. In this mode the TSF hashes messages of arbitrary 
						length. As there are different tests for each mode, an indication is given in the 
						following sections for the bit-oriented vs. the byte-oriented test MACs. The evaluator 
						shall perform all of the following tests for each hash algorithm implemented by the 
						TSF and used to satisfy the requirements of this PP.<h:p/>     
						The following tests require the developer to provide access to a test application
						that provides the evaluator with tools that are typically not found in the production application.
						<testlist>
							<test>Short Messages Test - Bit oriented Mode. The evaluators devise an input set
								consisting of m+1 messages, where m is the block length of the hash algorithm. The
								length of the messages range sequentially from 0 to m bits. The message text shall
								be pseudorandomly generated. The evaluators compute the message digest for each of
								the messages and ensure that the correct result is produced when the messages are
								provided to the TSF. </test>
							<test>Short Messages Test - Byte oriented Mode. The evaluators devise an input set
								consisting of m/8+1 messages, where m is the block length of the hash algorithm.
								The length of the messages range sequentially from 0 to m/8 bytes, with each
								message being an integral number of bytes. The message text shall be
								pseudorandomly generated. The evaluators compute the message digest for each of
								the messages and ensure that the correct result is produced when the messages are
								provided to the TSF. </test>
							<test>Selected Long Messages Test - Bit oriented Mode. The evaluators devise an input
								set consisting of m messages, where m is the block length of the hash algorithm.
								The length of the ith message is 512 + 99*i, where 1 ≤ i ≤ m. The message text
								shall be pseudorandomly generated. The evaluators compute the message digest for
								each of the messages and ensure that the correct result is produced when the
								messages are provided to the TSF. </test>
							<test>Selected Long Messages Test - Byte oriented Mode. The evaluators devise an
								input set consisting of m/8 messages, where m is the block length of the hash
								algorithm. The length of the ith message is 512 + 8*99*i, where 1 ≤ i ≤ m/8. The
								message text shall be pseudorandomly generated. The evaluators compute the message
								digest for each of the messages and ensure that the correct result is produced
								when the messages are provided to the TSF. </test>
							<test>Pseudorandomly Generated Messages Test. This test is for byte-oriented
								implementations only. The evaluators randomly generate a seed that is n bits long,
								where n is the length of the message digest produced by the hash function to be
								tested. The evaluators then formulate a set of 100 messages and associated digests
								by following the algorithm provided in Figure 1 of [SHAVS]. The evaluators then
								ensure that the correct result is produced when the messages are provided to the
								TSF. </test>
						</testlist>
					</Tests>
				</aactivity>
			</f-element>
        </f-component> 
		</change>
		
		<!-- FCS_COP.1/KeyedHash -->
		<change xpath=".//f-component[@id='fcom_key_hash']" mode="replace">
		   <f-component cc-id="fcs_cop.1" id="fcom_key_hash" iteration="KeyedHash" name="Cryptographic Operation - Keyed-Hash Message Authentication" status="sel-based">
			<!-- 8/3/22 WAS: <depends on="sel_all_tls"/> -->
			<!-- 1/25/23 WAS: <depends on1="sel_all_tls_cl" on2="sel_all_tls_sv"/> -->
			<!-- 2/1/23: Added HTTPS, IPsec, DTLS, and SSH IDs -->
			<depends on1="sel_all_https_cl" on2="sel_all_https_sv"  on3="sel_all_https_ma" on4="sel_all_ipsec" on5="sel_all_ssh" on6="sel_all_tls_cl" on7="sel_all_tls_sv" on8="sel_all_dtls_cl" on9="sel_all_dtls_sv"/>
			<!-- Also updated by TD0626 -->
			<f-element id="fel-keyed-hash">
				<title>The <h:b>application</h:b> shall perform <h:i>keyed-hash message authentication</h:i> in accordance with a 
					specified cryptographic algorithm<h:ul>
						<h:li>HMAC-SHA-256</h:li></h:ul>and
					<selectables linebreak="yes">
						<selectable>HMAC-SHA-256</selectable>
						<selectable>HMAC-SHA-384</selectable>
						<selectable>HMAC-SHA-512</selectable>
					</selectables> and 
					<selectables linebreak="yes">
						<selectable>HMAC-SHA-1</selectable>
						<selectable exclusive="yes">no other algorithms</selectable>
					</selectables> with key sizes <assignable>key size (in bits) used in HMAC</assignable> 
					and message digest sizes 
					<selectables>
						<selectable>256</selectable>
						<selectable>384</selectable>
						<selectable>512</selectable>
					</selectables> and 
					<selectables>	
						<selectable>160</selectable>
						<selectable exclusive="yes">no other size</selectable>
					</selectables>
					bits that meet the following: FIPS Pub 198-1 <h:i>The Keyed-Hash Message Authentication Code</h:i>
					and FIPS Pub 180-4 <h:i>Secure Hash Standard</h:i>.
				</title>
				<note role="application">
					This is dependent on implementing cryptographic functionality, as in FTP_DIT_EXT.1.<h:p/>
					The intent of this requirement is to specify the keyed-hash
					message authentication function used for key
					establishment purposes for the various cryptographic protocols
					used by the application (e.g., trusted channel). The hash selection must
					support the message digest size selection. The hash selection
					should be consistent with the overall strength of the algorithm used for FCS_COP.1/SKC.
				</note>
				<aactivity>
					The evaluator shall perform the following activities based on the selections in the ST.
					<TSS>None.<h:p/></TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						For each of the supported parameter sets, the evaluator shall compose 15 sets of test data.
						Each set shall consist of a key and message data.  The evaluator shall have the TSF generate
						HMAC tags for these sets of test data.  The resulting MAC tags shall be compared to the 
						result of generating HMAC tags with the same key and IV using a known-good implementation.
					</Tests>
				</aactivity>
			</f-element>
        </f-component> 
		</change>
		
		<!-- FCS_COP.1/Sign -->
		<change xpath=".//f-component[@id='fcom_sign']" mode="replace">
		   <f-component cc-id="fcs_cop.1" id="fcom_sign" iteration="Sig" name="Cryptographic Operation - Signing"  status="sel-based">
			<!-- 8/3/22 WAS: <depends on="sel_all_tls"/> -->
			<!-- 1/25/23 WAS: <depends on1="sel_all_tls_cl" on2="sel_all_tls_sv"/> -->
			<!-- 2/1/23: Added HTTPS, IPsec, DTLS, and SSH IDs -->
			<depends on1="sel_all_https_cl" on2="sel_all_https_sv"  on3="sel_all_https_ma" on4="sel_all_ipsec" on5="sel_all_ssh" on6="sel_all_tls_cl" on7="sel_all_tls_sv" on8="sel_all_dtls_cl" on9="sel_all_dtls_sv"/>
			<f-element id="fel-sign">
				<title>
					The <h:b>application</h:b> shall perform <h:i>cryptographic signature services (generation and
					verification)</h:i> in accordance with a specified cryptographic algorithm <selectables linebreak="yes">
						<selectable><h:b>RSA schemes</h:b> using cryptographic key sizes of 2048-bit or greater that meet the 
							following: FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Section 4</selectable>
						<selectable><h:b>ECDSA schemes</h:b> using “NIST curves” P-256, P-384 and <selectables>
							<selectable>P-521</selectable>
							<selectable exclusive="yes">no other curves</selectable></selectables>
						that meet the following: FIPS PUB 186-4, “Digital Signature Standard (DSS)”, Section 5</selectable>
					</selectables>.
				</title>
				<note role="application">
					This is dependent on implementing cryptographic functionality, as in FTP_DIT_EXT.1.<h:p/>
					The ST Author should choose the algorithm implemented to perform
					digital signatures; if more than one algorithm is available, this requirement should be iterated
					to specify the functionality. For the algorithm chosen, the ST author should make the
					appropriate assignments/selections to specify the parameters that are implemented for that
					algorithm.
				</note>
				<aactivity>
					The evaluator shall perform the following activities based on the selections in the ST.
					<TSS>None.<h:p/></TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						The following tests require the developer to provide access to a test application
						that provides the evaluator with tools that are typically not found in the production
						application. <h:p/>
						ECDSA Algorithm Tests
						<testlist>
							<test>ECDSA FIPS 186-4 Signature Generation Test. For each
								supported NIST curve (i.e., P-256, P-384 and P-521) and SHA function pair, the
								evaluator shall generate 10 1024-bit long messages and obtain for each message a
								public key and the resulting signature values R and S. To determine correctness,
								the evaluator shall use the signature verification function of a known good
								implementation. 
							</test>
							<test>
								ECDSA FIPS 186-4 Signature Verification Test. For each supported
								NIST curve (i.e., P-256, P-384 and P-521) and SHA function pair, the evaluator
								shall generate a set of 10 1024-bit message, public key and signature tuples and
								modify one of the values (message, public key or signature) in five of the 10
								tuples. The evaluator shall obtain in response a set of 10 PASS/FAIL values.
							</test>
						</testlist>
						RSA Signature Algorithm Tests
						<testlist>
							<test>Signature Generation Test. The evaluator shall
								verify the implementation of RSA Signature Generation by the TOE
								using the Signature Generation Test. To conduct this test the evaluator must 
								generate or obtain 10 messages from a trusted reference implementation for each 
								modulus size/SHA combination supported by the TSF. The evaluator 
								shall have the TOE use their private key and modulus value to 
								sign these messages. The evaluator shall verify the correctness of the 
								TSF’s signature using a known good implementation and the 
								associated public keys to verify the signatures.
							</test>
							<test>Signature Verification Test. The 
								evaluator shall perform the Signature Verification test to verify the ability of 
								the TOE to recognize another party’s valid and invalid 
								signatures. The evaluator shall inject errors into the test vectors produced 
								during the Signature Verification Test by introducing errors in some of the public 
								keys, e, messages, IR format, and/or signatures. The TOE attempts 
								to verify the signatures and returns success or failure.
							</test>
						</testlist>
					</Tests>
				</aactivity>
			</f-element>
        </f-component>
		</change>
		
		<!-- FIA_X509_EXT.1 -->
		<change xpath=".//f-component[@cc-id='fia_x509_ext.1']" mode="replace">
		<f-component cc-id="fia_x509_ext.1" name="X.509 Certificate Validation" status="sel-based">
			<!-- 8/3/22 WAS: <depends on1="sel_all_https_cl" on2="sel_all_https_sv" on3="sel_all_https_ma" on4="sel_all_tls" on5="sel_all_dtls"/> -->
			<!-- 1/25/23 WAS: <depends on1="sel_all_https_cl" on2="sel_all_https_ma" on3="sel_all_tls_cl" on4="sel_all_tls_sv_ma" on5="sel_all_dtls_cl" on6="sel_all_dtls_sv_ma"/> -->
			<depends on1="sel_all_https_cl" on2="sel_all_https_ma" on3="sel_enc_sens_https" on4="sel_enc_data_https" on5="sel_all_ipsec" on6="sel_all_dtls_cl" on7="sel_all_dtls_sv_ma" on8="sel_enc_sens_dtls" on9="sel_enc_data_dtls" on10="sel_all_tls_cl" on11="sel_all_tls_sv_ma" on12="sel_enc_sens_tls" on13="sel_enc_data_tls"/>
			<f-element id="fel-certauth-how">
				<title>
					The application shall 
					<selectables onlyone="yes">
						<selectable>invoke platform-provided functionality</selectable>
						<selectable>implement functionality</selectable>
					</selectables>
					to validate certificates in accordance with the following rules:<h:ul>
						<h:li>RFC 5280 certificate validation and certificate path validation.</h:li>
						<h:li>The certificate path must terminate with a trusted CA certificate.</h:li>
						<h:li>The application shall validate a certificate path by ensuring the presence of the 
							basicConstraints extension and that the CA flag is set to TRUE for all CA 
							certificates, and that any path constraints are met.
						</h:li>
						<h:li>The application shall validate that any CA certificate includes caSigning purpose in the key
							usage field</h:li>
						<h:li>The application shall validate the revocation status of the certificate using 
							<selectables>
								<selectable>OCSP as specified in RFC 6960</selectable>
								<selectable>CRL as specified in RFC 5280 Section 6.3</selectable>
								<selectable>CRL as specified in RFC 8603</selectable>
								<selectable>an OCSP TLS Status Request Extension (OCSP stapling) as specified in RFC 6066</selectable>
								<selectable>OCSP TLS Multi-Certificate Status Request Extension (i.e., OCSP Multi-Stapling) as specified in RFC 6961</selectable>
							</selectables>.
						</h:li>
						<h:li>The application shall validate the extendedKeyUsage (EKU) field according to the 
							following rules:<h:ul>
							<h:li>Certificates used for trusted updates and executable code integrity verification 
								shall have the Code Signing Purpose (id-kp 3 with OID 1.3.6.1.5.5.7.3.3) in the 
								extendedKeyUsage field.
							</h:li>
							<h:li>Server certificates presented for TLS shall have the Server Authentication
								purpose (id-kp 1 with OID 1.3.6.1.5.5.7.3.1) in the EKU field.
							</h:li>
							<h:li>
								Client certificates presented for TLS shall have the Client Authentication purpose 
								(id-kp 2 with OID 1.3.6.1.5.5.7.3.2) in the EKU field.
							</h:li>
							<h:li>
								S/MIME certificates presented for email encryption and signature shall have the 
								Email Protection purpose (id-kp 4 with OID 1.3.6.1.5.5.7.3.4) in the EKU field.
							</h:li>
							<h:li>
								OCSP certificates presented for OCSP responses shall have the OCSP Signing purpose 
								(id-kp 9 with OID 1.3.6.1.5.5.7.3.9) in the EKU field.
							</h:li>
							<h:li>
								Server certificates presented for EST shall have the CMC Registration Authority 
								(RA) purpose (id-kp-cmcRA with OID 1.3.6.1.5.5.7.3.28) in the EKU field.
							</h:li></h:ul>
						</h:li>
					</h:ul>
				</title>
				<note role="application">
					FIA_X509_EXT.1.1 lists the rules for validating certificates. The ST author shall select whether
					revocation status is verified using OCSP or CRLs. FIA_X509_EXT.2 requires that certificates are
					used for HTTPS, TLS, and DTLS; this use requires that the extendedKeyUsage rules are verified.
					If OCSP is not supported the EKU provision for checking the OCSP Signing purpose is met by 
					default.<h:p/>
					This requirement is included if the protocol(s) selected in FTP_DIT_EXT.1.1 require the use of
					certificates. If the TOE implements TLS as a HTTPS/TLS server with no mutual authentication,
					this requirement is not applicable.<h:p/>
					OCSP stapling and OCSP multi-stapling only support TLS server certificate validation. If other 
					certificate types are validated, either OCSP or CRL should be claimed.<h:p/>
					Regardless of the selection of "<h:i>implement functionality or invoke platform-provided 
					functionality</h:i>," the validation is expected to end in a trusted root CA certificate in a root
					store managed by the platform.
				</note>
				<aactivity level="element">
					<TSS>
						The evaluator shall ensure the TSS describes where the check of validity of the certificates
						takes place. The evaluator ensures the TSS also provides a description of the certificate 
						path validation algorithm.<h:p/>
					</TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						The tests described must be performed in conjunction with the other certificate services evaluation 
						activities, including the functions in FIA_X509_EXT.2.1. The tests for the extendedKeyUsage rules are 
						performed in conjunction with the uses that require those rules. If the application supports chains of
						length four or greater, the evaluator shall create a chain of at least four certificates: 
						the node certificate to be tested, two Intermediate CAs, and the self-signed Root CA. If 
						the application supports a maximum trust depth of two, then a chain with no Intermediate
						CA should instead be created.
						<testlist>
							<test>
								The evaluator shall demonstrate that validating a certificate without a valid certification path results in the function 
								failing, for each of the following reasons, in turn:<h:ul>
								<h:li>by establishing a certificate path in which one of the issuing certificates is not a CA certificate,</h:li>
								<h:li>by omitting the basicConstraints field in one of the issuing certificates,</h:li>
								<h:li>by setting the basicConstraints field in an issuing certificate to have CA=False,</h:li>
								<h:li>by omitting the CA signing bit of the key usage field in an issuing certificate, and</h:li>
								<h:li>by setting the path length field of a valid CA field to a value strictly less than the certificate path.</h:li>
								</h:ul>
								The evaluator shall then establish a valid certificate path consisting of valid CA certificates, and demonstrate that the 
								function succeeds. The evaluator shall then remove trust in one of the CA certificates, and show that the function fails.
							</test>
							<test>
								The evaluator shall demonstrate that validating an expired certificate results in the function failing.
							</test>
							<test>
								The evaluator shall test that the TOE can properly handle revoked certificates-“conditional on whether
								CRL, OCSP, OCSP Stapling or OCSP Multi-stapling is selected; if multiple methods are selected, then
								the following tests shall be performed for each method:
								<h:ul>
								<h:li>The evaluator shall test revocation of the node certificate.</h:li>
								<h:li>The evaluator shall also test revocation of an intermediate CA certificate (i.e. the intermediate
									CA certificate should be revoked by the root CA), if intermediate CA certificates are supported.
									If OCSP stapling per RFC 6066 is the only supported revocation method, this test is omitted.</h:li>
								<h:li>The evaluator shall ensure that a valid certificate is used, and that the validation function 
									succeeds. The evaluator then attempts the test with a certificate that has been revoked (for each 
									method chosen in the selection) to ensure when the certificate is no longer valid that the 
									validation function fails.</h:li>
								</h:ul>
							</test>
							<test>
								If any OCSP option is selected, the evaluator shall configure the OCSP server or use a
								man-in-the-middle tool to present a certificate that does not have the OCSP signing purpose and verify
								that validation of the OCSP response fails. If CRL is selected, the evaluator shall configure the CA 
								to sign a CRL with a certificate that does not have the cRLsign key usage bit set, and verify that
								validation of the CRL fails.
							</test>
							<test>
								The evaluator shall modify any byte in the first eight bytes of the certificate and demonstrate that 
								the certificate fails to validate. (The certificate will fail to parse correctly.)
							</test>
							<test>
								 The evaluator shall modify any byte in the last byte of the certificate and demonstrate that the 
								 certificate fails to validate. (The signature on the certificate will not validate.)
							</test>
							<test>
								The evaluator shall modify any byte in the public key of the certificate and demonstrate that the
								certificate fails to validate. (The signature on the certificate will not validate.)
							</test>
							<test>
								 (Conditional on support for EC certificates as indicated in FCS_COP.1/Sig). The evaluator shall establish a valid,
								 trusted certificate chain consisting of an EC leaf certificate, an EC Intermediate CA certificate not 
								 designated as a trust anchor, and an EC certificate designated as a trusted anchor, where the elliptic 
								 curve parameters are specified as a named curve. The evaluator shall confirm that the TOE validates 
								 the certificate chain.
							</test>
							<test>
								(Conditional on support for EC certificates as indicated in FCS_COP.1/Sig). The evaluator shall replace
								the intermediate certificate in the certificate chain for Test 9 with a modified certificate, where 
								the modified intermediate CA has a public key information field where the EC parameters uses an 
								explicit format version of the Elliptic Curve parameters in the public key information field of the
								intermediate CA certificate from Test 9, and the modified Intermediate CA certificate is signed by 
								the trusted EC root CA, but having no other changes. The evaluator shall confirm the TOE treats the
								certificate as invalid.
							</test>
						</testlist>
					</Tests>
				</aactivity>
			</f-element>
			<f-element id="fel-ca-who">
				<title>
					The application shall treat a certificate as a CA certificate only if the 
					basicConstraints extension is present and the CA flag is set to TRUE.
				</title>
				<note role="application">
					This requirement applies to certificates that are used and processed by the 
					TSF and restricts the certificates that may be added as trusted CA certificates.
				</note>
				<aactivity level="element">
					<TSS>None.<h:p/></TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						The tests described must be performed in conjunction with the other certificate 
						services evaluation activities, including the functions in FIA_X509_EXT.2.1.
						If the application supports chains of length four or greater, 
						the evaluator shall create a chain of at least four certificates: the 
						node certificate to be tested, two Intermediate CAs, and the self-signed Root CA.
						If the application supports a maximum trust depth of two, then a chain with
						no Intermediate CA should instead be created.
						<testlist>
							<test>
								The evaluator shall ensure that the certificate of at least one of the CAs in the chain does not contain the 
								basicConstraints extension. The evaluator shall confirm that validation of the certificate path 
								fails (i) as part of the validation of the peer certificate belonging to this chain; and/or 
								(ii) when attempting to add the CA certificate without the basicConstraints extension to the TOE's trust store.
							</test>
							<test>
								The evaluator shall ensure that the certificate of at least one of the CAs in the chain has the CA flag in the 
								basicConstraints extension not set (or set to FALSE). The evaluator shall confirm that validation of the certificate 
								path fails (i) as part of the validation of the peer certificate belonging to this chain; and/or (ii) when attempting 
								to add the CA certificate with the CA flag not set (or set to FALSE) in the basicConstraints extension to the TOE's trust store.
							</test>
						</testlist>
					</Tests>
				</aactivity>
			</f-element>
        </f-component>
		</change>
		
		<!-- FIA_X509_EXT.2 -->
		<change xpath=".//f-component[@cc-id='fia_x509_ext.2']" mode="replace">
		<f-component cc-id="fia_x509_ext.2" name="X.509 Certificate Authentication" status="sel-based">
			<!-- 8/3/22 WAS: <depends on1="sel_all_https_cl" on2="sel_all_https_sv" on3="sel_all_https_ma" on4="sel_all_tls" on5="sel_all_dtls"/> -->
			<!-- 1/25/23 WAS: <depends on1="sel_all_https_cl" on2="sel_all_https_ma" on3="sel_all_tls_cl" on4="sel_all_tls_sv_ma" on5="sel_all_dtls_cl" on6="sel_all_dtls_sv_ma"/> -->
			<depends on1="sel_all_https_cl" on2="sel_all_https_ma" on3="sel_enc_sens_https" on4="sel_enc_data_https" on5="sel_all_ipsec" on6="sel_all_dtls_cl" on7="sel_all_dtls_sv_ma" on8="sel_enc_sens_dtls" on9="sel_enc_data_dtls" on10="sel_all_tls_cl" on11="sel_all_tls_sv_ma" on12="sel_enc_sens_tls" on13="sel_enc_data_tls"/>
			<f-element id="fel-certs-who">
				<title>
					The application shall use X.509v3 certificates as defined by RFC 5280 to support authentication for 
					<selectables>
						<selectable>HTTPS</selectable>
						<selectable>TLS</selectable>
						<selectable>DTLS</selectable>
						<selectable>SSH</selectable>
						<selectable>IPsec</selectable>
					</selectables>. 
				</title>
				<note role="application">
					This requirement is included if the protocol(s) selected in FTP_DIT_EXT.1.1 require the use of certificates
					to authenticate the remote entity. For example, if the TOE or platform implements TLS as a HTTPS/TLS server
					with no mutual authentication, X509 authentication is not claimed for TLS. If the TOE or platform operates
					as a TLS client, X509 authentication must be claimed.				
				</note>
				<!-- 
				<aactivity>
				  Currently no EAs available.
				</aactivity>
				-->
			</f-element>
			<f-element id="fel-cert-fail">
				<title>
					When the application cannot establish a connection to determine the validity of a 
					certificate, the application shall  
					<selectables onlyone="yes">
						<selectable>allow the administrator to choose whether to accept the certificate in these cases</selectable>
						<selectable>accept the certificate</selectable>
						<selectable>not accept the certificate</selectable>
					</selectables>. 
				</title>
				<note role="application">
					Often a connection must be established to perform a verification of the revocation 
					status of a certificate - either to download a CRL or to perform OCSP. The selection 
					is used to describe the behavior in the event that such a connection cannot be 
					established (for example, due to a network error). If the TOE has 
					determined the certificate valid according to all other rules in FIA_X509_EXT.1,
					the behavior indicated in the selection shall determine the validity. The 
					TOE must not accept the certificate if it fails any of the other 
					validation rules in FIA_X509_EXT.1.
				</note>
				<aactivity>
					<TSS>
						The evaluator shall check the TSS to ensure that it describes how 
						the TOE chooses which certificates to use, and any necessary 
						instructions in the administrative guidance for configuring the operating environment 
						so that the TOE can use the certificates.<h:p/>
						The evaluator shall examine the TSS to confirm that it describes the 
						behavior of the TOE when a connection cannot be established during 
						the validity check of a certificate used in establishing a trusted channel. The 
						evaluator shall verify that any distinctions between trusted channels are described. 
						If the requirement that the administrator is able to specify the default action, then 
						the evaluator shall ensure that the operational guidance contains instructions on how 
						this configuration action is performed.<h:p/>
					</TSS>
					<Guidance>None.<h:p/></Guidance>
					<Tests>
						The evaluator shall perform the following test for each trusted channel:
						<testlist>
							<test>
								The evaluator shall demonstrate that using a valid certificate that requires 
								certificate validation checking to be performed in at least some part by 
								communicating with a non-TOE IT entity. The evaluator shall then 
								manipulate the environment so that the TOE is unable to verify 
								the validity of the certificate, and observe that the action selected in 
								FIA_X509_EXT.2.2 is performed. If the selected action is 
								administrator-configurable, then the evaluator shall follow the operational 
								guidance to determine that all supported administrator-configurable options behave 
								in their documented manner.
							</test>
							<test>
								The evaluator shall demonstrate that an invalid certificate that requires 
								certificate validation checking to be performed in at least some part by 
								communicating with a non-TOE IT entity cannot be accepted. 
							</test>
						</testlist>
					</Tests>
				</aactivity>
			</f-element>
        </f-component>
	</change>
    </decision>
  </bunch>
</technical-decisions>